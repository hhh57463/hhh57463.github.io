<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-07-05T21:11:55+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Mindol</title><subtitle>Mindol&apos;s Blog</subtitle><author><name>Mindol</name></author><entry><title type="html">Asset Bundle</title><link href="http://localhost:4000/unity/2023/07/04/Asset-Bundle.html" rel="alternate" type="text/html" title="Asset Bundle" /><published>2023-07-04T06:00:01+09:00</published><updated>2023-07-04T06:00:01+09:00</updated><id>http://localhost:4000/unity/2023/07/04/Asset%20Bundle</id><content type="html" xml:base="http://localhost:4000/unity/2023/07/04/Asset-Bundle.html"><![CDATA[<h2 id="개요">개요</h2>
<hr />
<p>회사에 인턴을 가게 되었는데 리소스가 자그마치 50GB가 넘었다. 이에 실장님이 리소스를 프로젝트에 넣지 않고 실행시키게 요청을 하였고 구글링 결과 에셋 번들에 대해 알게 되었다.</p>

<h2 id="에셋-번들">에셋 번들</h2>
<hr />
<p>에셋 번들: 프로젝트에 존재하는 에셋들을 일정한 규칙으로 묶어 정리하는 것</p>

<p>에셋 번들 빌드: 에셋번만 따로 빌드하는 것</p>

<p><code class="language-plaintext highlighter-rouge">에셋 번들 빌드를 완료한 뒤, 전체 프로젝트를 빌드하면 에셋번들을 제외한 나머지만 빌드가 이뤄지며, 빌드시 용량이 줄어들지만 최초 실행시 곧장 프로그램 사용이 불가하며 에셋 번들을 다운받아야함</code></p>

<h2 id="에셋-번들의-장점">에셋 번들의 장점</h2>

<ul>
  <li>용량: 용량이 줄어들어 용량제한(스토어에 올릴 상황 등)에 자유로움</li>
  <li>패치: 수정사항이나 추가패치 때마다 재설치 대신 에셋 번들만 추가 다운로드하면 됨</li>
</ul>

<h2 id="에셋-번들-생성">에셋 번들 생성</h2>
<hr />
<p><img src="/assets/img/Unity/AssetBundle_1.png" alt="Image" /></p>

<p>프로젝트에서 에셋을 설치 후 빌드하여 용량을 살펴보면</p>

<p><img src="/assets/img/Unity/AssetBundle_2.png" alt="Image" /></p>

<p>101MB가 나온다</p>

<p><img src="/assets/img/Unity/AssetBundle_3.png" alt="Image" /></p>

<p>에셋번들을 만들 에셋의 폴더를 지정 후 Inspector 하단의 AssetBundle을 지정해준다.</p>

<p><img src="/assets/img/Unity/AssetBundle_4.png" alt="Image" /></p>

<p>유니티 툴바에 새로운 기능을 만들기 위해 Assets→Editor 디렉토리를 만든 후 기능을 추가할 스크립트를 생성한다.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System.IO</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEditor</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">AssetbundleBuildManager</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">MenuItem</span><span class="p">(</span><span class="s">"BundleBuild/AssetBundle Build"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">AssetBundleBuild</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">string</span> <span class="n">directory</span> <span class="p">=</span> <span class="s">"./Bundle"</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(!</span><span class="n">Directory</span><span class="p">.</span><span class="nf">Exists</span><span class="p">(</span><span class="n">directory</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">Directory</span><span class="p">.</span><span class="nf">CreateDirectory</span><span class="p">(</span><span class="n">directory</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">BuildPipeline</span><span class="p">.</span><span class="nf">BuildAssetBundles</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">BuildAssetBundleOptions</span><span class="p">.</span><span class="n">None</span><span class="p">,</span><span class="n">BuildTarget</span><span class="p">.</span><span class="n">StandaloneWindows</span><span class="p">);</span>
		<span class="n">EditorUtility</span><span class="p">.</span><span class="nf">DisplayDialog</span><span class="p">(</span><span class="s">"에셋 번들 빌드"</span><span class="p">,</span> <span class="s">"에셋 번들 빌드 완료"</span><span class="p">,</span> <span class="s">"완료"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>빌드 기능을 제작할 것이기에 System.IO 지시문과 유니티 에디터를 수정하기에 UnityEditor를 추가해준다.</p>

<p>유니티의 컴포넌트가 필요없기에 MonoBehaviour도 지워준다</p>

<p><img src="/assets/img/Unity/AssetBundle_5.png" alt="Image" /></p>

<p><code class="language-plaintext highlighter-rouge">[MenuItem("BundleBuild/AssetBundle Build")]</code> 에디터 탭에 추가하기 위해 사용하며 BundleBuild라는 탭 아래 AssetBundle Build가 생긴것을 볼 수 있다.</p>

<p><img src="/assets/img/Unity/AssetBundle_6.png" alt="Image" /></p>

<p>Assets폴더 아래 Bundle이라는 디렉토리 안에 저장하며 만약 Bundle 디렉토리가 없을 시 새로 만든다</p>

<p>BuildPipeline.BuildAssetBundles의 매개변수는 총 3가지가 들어가는데 순서는 아래와 같다</p>

<ol>
  <li>경로: 지정한 경로</li>
  <li>에셋 번들 옵션: 압축 방식</li>
  <li>플랫폼: 사용 플랫폼에 맞춰 적용</li>
</ol>

<p><img src="/assets/img/Unity/AssetBundle_7.png" alt="Image" /></p>

<p>코드 작성 후 생성된 번들 빌드 버튼을 클릭한 후 조금 기다리면 빌드 완료 창이 나온다.</p>

<p><img src="/assets/img/Unity/AssetBundle_8.png" alt="Image" /></p>

<p>프로젝트 디렉토리에 가면 Bundle 디렉토리가 생성된 것을 볼 수 있다.</p>

<p><img src="/assets/img/Unity/AssetBundle_9.png" alt="Image" /></p>

<p>지정한 에셋 번들 이름의 파일이 생긴것을 볼 수 있는데 이곳에 지정한 리소스가 압축된 것이다.</p>

<h2 id="에셋-번들-로드">에셋 번들 로드</h2>
<hr />
<p><img src="/assets/img/Unity/AssetBundle_10.png" alt="Image" /></p>

<p>에셋 번들을 사용할 것이기에 원래 올려놓았던 프리팹을 삭제후 LoadManager라는 스크립트를 생성하였다.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">LoadManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="n">IEnumerator</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">AssetBundle</span> <span class="n">asset</span> <span class="p">=</span> <span class="n">AssetBundle</span><span class="p">.</span><span class="nf">LoadFromFile</span><span class="p">(</span><span class="s">"Bundle/charactor"</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">asset</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">yield</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">var</span> <span class="n">hero</span> <span class="p">=</span> <span class="n">asset</span><span class="p">.</span><span class="n">LoadAsset</span><span class="p">&lt;</span><span class="n">GameObject</span><span class="p">&gt;(</span><span class="s">"Hero"</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">player</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">hero</span><span class="p">);</span>
        <span class="n">player</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">zero</span><span class="p">;</span>

				<span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">WaitUntil</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetMouseButtonDown</span><span class="p">(</span><span class="m">0</span><span class="p">));</span>
        <span class="nf">Destroy</span><span class="p">(</span><span class="n">player</span><span class="p">);</span>
        <span class="n">asset</span><span class="p">.</span><span class="nf">Unload</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Start를 코루틴으로 변경해준 후 코드를 작성해준다.</p>

<p><code class="language-plaintext highlighter-rouge">AssetBundle asset = AssetBundle.LoadFromFile("Bundle/charactor");</code></p>

<p>에셋 번들이 있는 디렉토리의 주소를 적어주면 된다.</p>

<p><code class="language-plaintext highlighter-rouge">var hero = asset.LoadAsset&lt;GameObject&gt;("Hero")</code> 에셋 번들에 존재하는 오브젝트를 GameObject로 저장한다.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">yield</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">WaitUntil</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetMouseButtonDown</span><span class="p">(</span><span class="m">0</span><span class="p">));</span>
<span class="nf">Destroy</span><span class="p">(</span><span class="n">player</span><span class="p">);</span>
<span class="n">asset</span><span class="p">.</span><span class="nf">Unload</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
</code></pre></div></div>

<p>위코드는 불러온 에셋 번들의 메모리를 해제하는 작업으로 예시를 통해 마우스 클릭시 해제되게 하였다.</p>

<p><img src="/assets/img/Unity/AssetBundle_11.png" alt="Image" /></p>

<p>코드 실행시 잘 작동하는 것을 볼 수 있다.</p>

<p><img src="/assets/img/Unity/AssetBundle_12.png" alt="Image" /></p>

<p>빌드 후 용량을 확인해보면 용량이 줄어든 것을 볼 수 있다.</p>

<p><img src="/assets/img/Unity/AssetBundle_13.png" alt="Image" /></p>

<p>하지만 빌드파일을 실행하면 아무것도 일어나지 않는것을 볼 수 있는데, 이는 번들 파일이 없기 때문이다.</p>

<p><img src="/assets/img/Unity/AssetBundle_14.png" alt="Image" /></p>

<p>빌드 디렉토리에 번들 디렉토리를 옮긴 후 실행하면</p>

<p><img src="/assets/img/Unity/AssetBundle_15.png" alt="Image" /></p>

<p>오브젝트가 잘 생성되는 것을 볼 수 있다.</p>

<p>번들 파일이 저장되는 코드를 작성하면 되는 것이다.</p>

<h3 id="출처">출처</h3>

<p><a href="https://youtu.be/mC2d94bfI2w">오늘코딩 - 초보자를 위한 에셋번들</a></p>]]></content><author><name>Mindol</name></author><category term="Unity" /><category term="unity" /><category term="study" /><summary type="html"><![CDATA[유니티 에셋 번들]]></summary></entry><entry><title type="html">Navigation</title><link href="http://localhost:4000/unity/2023/06/16/Navigation.html" rel="alternate" type="text/html" title="Navigation" /><published>2023-06-16T07:00:00+09:00</published><updated>2023-06-16T07:00:00+09:00</updated><id>http://localhost:4000/unity/2023/06/16/Navigation</id><content type="html" xml:base="http://localhost:4000/unity/2023/06/16/Navigation.html"><![CDATA[<h2 id="navigation">Navigation?</h2>

<hr />

<p>특정 영역의 길을 AI가 최단 경로를 찾아 목적지에 도달하게 도와주는 기능</p>

<h2 id="navigation-설정">Navigation 설정</h2>

<hr />

<p>Navigation을 사용하기 위해서는 이동 가능한 경로를 지정하는 작업이 필요하다.</p>

<p><img src="/assets/img/Unity/Navigation_1.png" alt="image" /></p>

<p>Window → AI → Navigation (Obsolete)</p>

<p><img src="/assets/img/Unity/Navigation_2.png" alt="image" /></p>

<p>Navigation 경로를 지정할 수 있는 탭이 켜진다.</p>

<p><img src="/assets/img/Unity/Navigation_3.png" alt="image" /></p>

<p>이동할 바닥, 장애물을 모두 선택한 후(Mesh Renderer가 있는 오브젝트)</p>

<p><img src="/assets/img/Unity/Navigation_4.png" alt="image" /></p>

<p>Navigation Static을 체크 해준다.</p>

<h3 id="object">Object</h3>

<ul>
  <li>Scene Filter: 캐릭터가 이동할 수 있는 영역을 선택 (Mesh renderer와 Terrain이 존재하는 오브젝트만 지정 가능)</li>
  <li>Navigation Static: 해당 오브젝트를 캐릭터가 기을 찾을 수 있는 표면으로 지정</li>
  <li>Generate OffMeshLinks:  Off Mesh Link를 생성함</li>
  <li>Navigation Area: 해당 오브젝트의 영역 타입 설정 (Walkable, Not Walkable, Jump)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Off Mesh Link: 걸을 수 있는 내비게이션 메시 표면 외 지나갈 수 있는 경로를 만들 수 있음 (장애물 점프, 지나가기 전 문열기 등)</code></p>

<h3 id="areas">Areas</h3>

<p><img src="/assets/img/Unity/Navigation_5.png" alt="image" /></p>

<p>Areas는 캐릭터가 지날 수 있는 영역의 비용을 지정할 수 있다.</p>

<h3 id="bake">Bake</h3>

<p>오브젝트들의 설정이 끝났으면 Bake 탭에서 경로를 구워줘야 한다.</p>

<p><img src="/assets/img/Unity/Navigation_6.png" alt="image" /></p>

<p>하단의 Bake 버튼을 눌러주면</p>

<p><img src="/assets/img/Unity/Navigation_7.png" alt="image" /></p>

<p>맵 오브젝트 바닥에 파란색이 칠해지는 것을 볼 수 있다.</p>

<p>이는 캐릭터가 이동할 수 있는 경로가 칠해진 것이다.</p>

<h2 id="캐릭터-이동">캐릭터 이동</h2>

<hr />

<p><img src="/assets/img/Unity/Navigation_8.png" alt="image" /></p>

<p>캐릭터에게 Nav Mesh Agent 컴포넌트를 추가한다.</p>

<h3 id="프로퍼티">프로퍼티</h3>

<table>
  <thead>
    <tr>
      <th>프로퍼티</th>
      <th>기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Agent Type</td>
      <td>저장된 에이전트 선택</td>
    </tr>
    <tr>
      <td>Base Offset</td>
      <td>캐릭터의 충돌 위치</td>
    </tr>
    <tr>
      <td>Speed</td>
      <td>최대 이동 속도</td>
    </tr>
    <tr>
      <td>Angular Speed</td>
      <td>최대 회전 속도</td>
    </tr>
    <tr>
      <td>Acceleration</td>
      <td>최대 가속</td>
    </tr>
    <tr>
      <td>Stopping Distance</td>
      <td>도착 위치에서 얼마나 떨어진 위치에서 멈출지 지정</td>
    </tr>
    <tr>
      <td>Auto Braking</td>
      <td>도착 위치에 다다를 때 속도를 줄임</td>
    </tr>
    <tr>
      <td>Radius</td>
      <td>캐릭터의 충돌 범위</td>
    </tr>
    <tr>
      <td>Height</td>
      <td>캐릭터의 충돌 높이</td>
    </tr>
    <tr>
      <td>Quality</td>
      <td>장애물 회피 품질</td>
    </tr>
    <tr>
      <td>Priority</td>
      <td>해당 숫자보다 큰 숫자를 가진 오브젝트는 회피 대상에서 제외</td>
    </tr>
    <tr>
      <td>Auto Traverse Off Mesh Link</td>
      <td>Off Mesh Link 횡단 방법<br />- True: 자동으로 횡단<br />- Fasle: 특정 방법으로 횡단</td>
    </tr>
    <tr>
      <td>Auto Repath</td>
      <td>경로의 끝에 도달하면 경로 재탐색</td>
    </tr>
    <tr>
      <td>Area Mask</td>
      <td>어떠한 영역 타입을 이동할 것인지 (캐릭터 마다 이동 영역을 다르게 할 수 있음)</td>
    </tr>
  </tbody>
</table>

<p>코드로 바닥에 우클릭을 클릭하면 해당 위치로 이동하는 코드를 구현한다.</p>

<h3 id="이동">이동</h3>

<p>마우스 우클릭을 한 위치로 플레이어가 이동하는 코드를 구현해 주었다.</p>

<p><img src="/assets/img/Unity/nav_gif1.gif" alt="image" /></p>

<p>지정한 위치로 이동하는 것을 볼 수 있지만 경로가 나타나지 않아 보기 어려워 경로와 도착지를 표시해 주겠다.</p>

<p><img src="/assets/img/Unity/nav_gif2.gif" alt="image" /></p>

<p>지정된 경로로 이동하는 것을 볼 수 있다.</p>

<h2 id="카메라-이동">카메라 이동</h2>

<hr />

<p>고정된 카메라로 경로를 지정하려니 불편하여 카메라를 이동하는 코드를 적용하였다.</p>

<p><img src="/assets/img/Unity/nav_gif3.gif" alt="image" /></p>

<p>지정된 키를 눌러 이동 키를 눌러 카메라를 이동할 수 있다..</p>

<h2 id="nav-mesh-obstacle">Nav Mesh Obstacle</h2>

<hr />

<p>경로 위 장애물을 추가할 수 있다.</p>

<p><img src="/assets/img/Unity/Navigation_9.png" alt="image" /></p>

<p>장애물을 하나 만든 후 Nav Mesh Obstacle 컴포넌트를 추가해 주었다.</p>

<h3 id="프로퍼티-1">프로퍼티</h3>

<ul>
  <li>Shpe: 장애물의 형태를 지정. (Capsule, Cube)</li>
  <li>Center: 장애물의 충돌 범위 위치를 지정.</li>
  <li>Size: 장애물의 충돌 범위 크기를 지정.</li>
  <li>Carve: 경로상에 장애물이 있을 시 장애물을 피해 경로를 지정할 여부를 지정.</li>
</ul>

<p><img src="/assets/img/Unity/Navigation_10.png" alt="image" /></p>

<p>Carve를 True로 지정하면 다시 Bake를 하지 않아도 캐릭터의 이동 경로가 제한되는 것을 볼 수 있다.</p>

<h3 id="carve-false">Carve: False</h3>

<p><img src="/assets/img/Unity/nav_gif4.gif" alt="image" /></p>

<h3 id="carve-true">Carve: True</h3>

<p><img src="/assets/img/Unity/nav_gif5.gif" alt="image" /></p>

<p>Carve의 여부에 따라 이동 경로가 차이나는 것을 볼 수 있다.</p>

<h2 id="캐릭터-카메라-이동-코드">캐릭터, 카메라 이동 코드</h2>

<hr />

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine.AI</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Move</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="c1">////////////////// Player ///////////////////////////////////</span>
    <span class="n">NavMeshAgent</span> <span class="n">agent</span><span class="p">;</span>
    <span class="n">Animator</span> <span class="n">anime</span><span class="p">;</span>
    <span class="n">LineRenderer</span> <span class="n">lr</span><span class="p">;</span>
    <span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span> <span class="n">Transform</span> <span class="n">point</span><span class="p">;</span>
    <span class="n">Coroutine</span> <span class="n">path</span><span class="p">;</span>

    <span class="c1">////////////////// Camera ///////////////////////////////////</span>
    <span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span> <span class="n">KeyCode</span> <span class="n">camMoveSwap</span> <span class="p">=</span> <span class="n">KeyCode</span><span class="p">.</span><span class="n">Space</span><span class="p">;</span>
    <span class="n">Vector3</span> <span class="n">camMoveDir</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">camSpeed</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">viewDirX</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">viewDirY</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">rotSpeed</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">camMove</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">agent</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">NavMeshAgent</span><span class="p">&gt;();</span>
        <span class="n">anime</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Animator</span><span class="p">&gt;();</span>
        <span class="n">lr</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">LineRenderer</span><span class="p">&gt;();</span>

        <span class="n">rotSpeed</span> <span class="p">=</span> <span class="m">3.0f</span><span class="p">;</span>
        <span class="n">camSpeed</span> <span class="p">=</span> <span class="m">1.5f</span><span class="p">;</span>
        <span class="n">camMove</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="n">lr</span><span class="p">.</span><span class="n">startWidth</span> <span class="p">=</span> <span class="m">0.1f</span><span class="p">;</span>
        <span class="n">lr</span><span class="p">.</span><span class="n">endWidth</span> <span class="p">=</span> <span class="m">0.1f</span><span class="p">;</span>
        <span class="n">lr</span><span class="p">.</span><span class="n">material</span><span class="p">.</span><span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">green</span><span class="p">;</span>
        <span class="n">lr</span><span class="p">.</span><span class="n">enabled</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nf">PlayerMove</span><span class="p">();</span>
        <span class="nf">CameraMove</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">float</span> <span class="n">h</span> <span class="p">=&gt;</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">v</span> <span class="p">=&gt;</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Vertical"</span><span class="p">);</span>
    <span class="k">void</span> <span class="nf">CameraMove</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="nf">GetKeyDown</span><span class="p">(</span><span class="n">camMoveSwap</span><span class="p">))</span>
            <span class="n">camMove</span> <span class="p">=</span> <span class="p">!</span><span class="n">camMove</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">camMove</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">camMoveDir</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
            <span class="n">camMoveDir</span> <span class="p">=</span> <span class="n">Camera</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="nf">TransformDirection</span><span class="p">(</span><span class="n">camMoveDir</span><span class="p">);</span>
            <span class="n">Camera</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">+=</span> <span class="n">camMoveDir</span> <span class="p">*</span> <span class="n">camSpeed</span><span class="p">;</span>
            <span class="n">viewDirX</span> <span class="p">+=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Mouse X"</span><span class="p">)</span> <span class="p">*</span> <span class="n">rotSpeed</span><span class="p">;</span>
            <span class="n">viewDirY</span> <span class="p">+=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Mouse Y"</span><span class="p">)</span> <span class="p">*</span> <span class="p">-</span><span class="n">rotSpeed</span><span class="p">;</span>
            <span class="n">Camera</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">rotation</span> <span class="p">=</span> <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="n">viewDirY</span><span class="p">,</span> <span class="n">viewDirX</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">PlayerMove</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="nf">GetMouseButtonDown</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">Ray</span> <span class="n">ray</span> <span class="p">=</span> <span class="n">Camera</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="nf">ScreenPointToRay</span><span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="n">mousePosition</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">Physics</span><span class="p">.</span><span class="nf">Raycast</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="k">out</span> <span class="n">RaycastHit</span> <span class="n">hit</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">agent</span><span class="p">.</span><span class="nf">SetDestination</span><span class="p">(</span><span class="n">hit</span><span class="p">.</span><span class="n">point</span><span class="p">);</span>
                <span class="n">anime</span><span class="p">.</span><span class="nf">SetFloat</span><span class="p">(</span><span class="s">"Speed"</span><span class="p">,</span> <span class="m">2.0f</span><span class="p">);</span>
                <span class="n">point</span><span class="p">.</span><span class="n">gameObject</span><span class="p">.</span><span class="nf">SetActive</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
                <span class="n">point</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">hit</span><span class="p">.</span><span class="n">point</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">path</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                    <span class="nf">StopCoroutine</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
                <span class="n">path</span> <span class="p">=</span> <span class="nf">StartCoroutine</span><span class="p">(</span><span class="nf">DrawPath</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">agent</span><span class="p">.</span><span class="n">remainingDistance</span> <span class="p">&lt;</span> <span class="m">0.1f</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">anime</span><span class="p">.</span><span class="nf">SetFloat</span><span class="p">(</span><span class="s">"Speed"</span><span class="p">,</span> <span class="m">0.0f</span><span class="p">);</span>
            <span class="n">point</span><span class="p">.</span><span class="n">gameObject</span><span class="p">.</span><span class="nf">SetActive</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
            <span class="n">lr</span><span class="p">.</span><span class="n">enabled</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">path</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                <span class="nf">StopCoroutine</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">IEnumerator</span> <span class="nf">DrawPath</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">lr</span><span class="p">.</span><span class="n">enabled</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">cnt</span> <span class="p">=</span> <span class="n">agent</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">corners</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
            <span class="n">lr</span><span class="p">.</span><span class="n">positionCount</span> <span class="p">=</span> <span class="n">cnt</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">lr</span><span class="p">.</span><span class="nf">SetPosition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">agent</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">corners</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="참고">참고</h2>

<hr />

<p><a href="https://docs.unity3d.com/kr/2021.3/Manual/class-NavMeshAgent.html">내비메시 에이전트 - Unity 매뉴얼</a></p>

<p><a href="https://www.youtube.com/watch?v=ILefNAZGVFY">오늘코딩-Navigation</a></p>]]></content><author><name>Mindol</name></author><category term="Unity" /><category term="unity" /><category term="study" /><summary type="html"><![CDATA[유니티 Navigation]]></summary></entry><entry><title type="html">SQL 최적화</title><link href="http://localhost:4000/database/2023/06/10/SQL-%EC%B5%9C%EC%A0%81%ED%99%94.html" rel="alternate" type="text/html" title="SQL 최적화" /><published>2023-06-10T06:00:01+09:00</published><updated>2023-06-10T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/10/SQL%20%EC%B5%9C%EC%A0%81%ED%99%94</id><content type="html" xml:base="http://localhost:4000/database/2023/06/10/SQL-%EC%B5%9C%EC%A0%81%ED%99%94.html"><![CDATA[<h2 id="옵티마이저optimizer">옵티마이저(Optimizer)</h2>

<hr />

<ul>
  <li>SQL의 실행 계획을 수립하고 SQL을 실행하는 DBMS의 소프트웨어</li>
  <li>데이터 딕셔너리에 있는 오브젝트 통계, 시스템 통계 등의 정보를 사용하여 예상되는 비용을 산정</li>
  <li>여러 실행 계획 중 최저비용을 가지는 계획을 선택하여 SQL 실행</li>
  <li>SQL 실행 계획을 PLAN_TABLE에 저장</li>
  <li>PLAN_TABLE을 조회하여 실행 계획 확인 가능</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">TABLE ACCESS FULL: 테이블의 전체를 모두 읽었다는 의미</code></p>

<h3 id="옵티마이저-엔진">옵티마이저 엔진</h3>

<table>
  <thead>
    <tr>
      <th>옵티마이저</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Query Transformer</td>
      <td>- SQL문을 효율적으로 실행하기 위해 옵티마이저가 변환<br />- SQL이 변환되어도 결과는 동일</td>
    </tr>
    <tr>
      <td>Estimator</td>
      <td>- 통계정보를 사용하여 SQL 실행비용 계산<br />- 총 비용은 최적의 실행 계획을 수립하기 위함</td>
    </tr>
    <tr>
      <td>Plan Generator</td>
      <td>SQL을 실행할 실행 계획 수립</td>
    </tr>
  </tbody>
</table>

<h3 id="규칙-기반-옵티마이저rule-base-optimizer">규칙 기반 옵티마이저(Rule base Optimizer)</h3>

<p>실행 계획을 수립할 때 15개의 우선순위를 기준으로 실행 계획 수립</p>

<ol>
  <li>ROWID를 사용한 단일 행인 경우</li>
  <li>클러스터 조인에 의한 단일 행인 경우</li>
  <li>유일하거나 기본키를 가진 해시 클러스터 키에 의한 단일 행인 경우</li>
  <li>유일하거나 기본키에 의한 단일 행인 경우</li>
  <li>클러스터 조인인 경우</li>
  <li>해시 클러스터 조인인 경우</li>
  <li>인덱스 클러스터 키인 경우</li>
  <li>복합 칼럼 인덱스인 경우</li>
  <li>단일 칼럼 인덱스인 경우</li>
  <li>인덱스가 구성된 칼럼에서 제한된 범위를 검색하는 경우</li>
  <li>인덱스가 구성된 칼럼에서 무제한 범위를 검색하는 경우</li>
  <li>정렬-병합 조인(Sort Merge)인 경우</li>
  <li>인덱스가 구성된 칼럼에서 MAX 혹은 MIN을 구하는 경우</li>
  <li>인덱스가 구성된 칼럼에서 ORDER BY를 실행하는 경우</li>
  <li>전체 테이블을 스캔(FULL TABLE SCAN)하는 경우</li>
</ol>

<h3 id="비용-기반-옵티마이저cost-base-optimizer">비용 기반 옵티마이저(Cost base Optimizer)</h3>

<ul>
  <li>오브젝트 통계 및 시스템 통계를 사용하여 총비용을 계산</li>
  <li>총비용이 적은 쪽으로 실행 계획 수립</li>
  <li>통계정보가 부적절한 경우 성능 저하가 발생할 수 있음</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">총비용: SQL문을 실행하기 위해 예상되는 소요시간 혹은 자원의 사용량</code></p>

<h2 id="인덱스index">인덱스(Index)</h2>

<hr />

<ul>
  <li>데이터를 빠르게 검색할 수 있는 방법 제공</li>
  <li>인덱스 키로 정렬되어 있기에 원하는 데이터를 빠르게 조회</li>
  <li>오름차순 및 내림차순 탐색 가능</li>
  <li>하나의 테이블에 여러 인덱스 생성 가능, 하나의 인덱스는 여러 칼럼으로 구성될 수 있음</li>
  <li>테이블 생성시 기본키는 자동으로 인덱스가 만들며, 인덱스의 이름은 SYSXXXX</li>
  <li>인덱스의 구조는 Root Block, Branch Block, Leaf Block으로 구성</li>
</ul>

<h3 id="인덱스의-구조">인덱스의 구조</h3>

<table>
  <thead>
    <tr>
      <th>구조</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Root Block</td>
      <td>인덱스 트레에서 가장 상위에 있는 노드</td>
    </tr>
    <tr>
      <td>Branch Block</td>
      <td>다음 단계의 주소를 가지고 있는 포인터로 구성</td>
    </tr>
    <tr>
      <td>Leaf Block</td>
      <td>- 인덱스 키와 ROWID로 구성되며, 인덱스 키는 정렬되어 저장되어 있음<br />- Double Linked List 형태로 되어있어 양방향 탐색 가능<br />- 인덱스 키를 읽으면 ROWID를 사용하여 테이블의 행을 직접 읽을 수 있음</td>
    </tr>
  </tbody>
</table>

<h3 id="인덱스-생성">인덱스 생성</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="err">인덱스이름</span> <span class="err">테이블</span> <span class="k">ON</span> <span class="err">테이블</span><span class="p">(</span><span class="err">칼럼</span><span class="mi">1</span> <span class="err">정렬방법</span><span class="p">,</span> <span class="err">칼럼</span><span class="mi">2</span> <span class="err">정렬방법</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">정렬 방법을 생략하면 오름차순으로 정렬하며 'DESC'를 사용하면 내림차순 정렬 가능</code></p>

<h3 id="인덱스-스캔">인덱스 스캔</h3>

<table>
  <thead>
    <tr>
      <th>스캔</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>인덱스 유일 스캔<br />(Index Unique Scan)</td>
      <td>인덱스의 키 값이 중복되지 않는 경우, 해당 인덱스를 사용할 때 발생</td>
    </tr>
    <tr>
      <td>인덱스 범위 스캔<br />(Index Range Scan)</td>
      <td>SELECT문에서 특정 범위를 조회하는 WHERE문을 사용할 경우 발생</td>
    </tr>
    <tr>
      <td>인덱스 전체 스캔<br />(Index Full Scan)</td>
      <td>인덱스에서 검색되는 인덱스 키가 많은 경우 Leaf Block의 처음부터 끝까지 전체를 읽음</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">Hight Watermark: 테이블에 데이터가 저장된 블록에서 최상위 위치</code></p>

<h2 id="실행-계획execution-plan">실행 계획(Execution Plan)</h2>

<hr />

<ul>
  <li>부모자식 중에는 자식이우선</li>
  <li>형제간에는 형이 우선</li>
</ul>

<h2 id="옵티마이저-조인optimizer-join">옵티마이저 조인(Optimizer Join)</h2>

<hr />

<h3 id="nested-loop-조인">Nested Loop 조인</h3>

<ul>
  <li>하나의 테이블에서 데이터를 먼저 찾고 그다음 테이블을 조인하는 방식으로 실행</li>
  <li>먼저 조회되는 테이블을 외부 테이블(Outer Table)이라 하며 그다음 테이블을 내부 테이블(Inner Table)이라 함</li>
  <li>외부 테이블(선행테이블)의 크기가 작은 것을 먼저 찾는 것이 중요(데이터가 스캔되는 범위를 줄일 수 있기 때문)</li>
  <li>RANDOM ACCESS가 발생하며 RANDOM ACCESS가 많이 발생하면 성능 지연 발생</li>
</ul>

<h3 id="sort-merge-조인">Sort Merge 조인</h3>

<ul>
  <li>두 개의 테이블을 SORT_AREA라는 메모리 공간에 모두 로딩한 후 정렬(Sort) 수행</li>
  <li>두 테이블의 정렬이 완료되면 두 개의 테이블을 병합(Merge)</li>
  <li>Sort Merge 조인은 정렬이 발생하기에 데이터양이 많아지면 성능이 떨어짐</li>
  <li>정렬 데이터양이 너무 많으면 정렬은 임시 영역에서 수행</li>
  <li>임시 영역은 디스크에 있기에 성능이 급격히 떨어짐</li>
</ul>

<h3 id="hash-조인">Hash 조인</h3>

<ul>
  <li>두 개의 테이블 중 작은 테이블을 HASH 메모리에 로딩후 두 테이블의 조인 키를 사용하여 해시 테이블 생성</li>
  <li>해시 함수를 사용하여 주소를 계산하고 해당 주소를 사용하여 테이블을 조인하기에 많은 CPU 연산 발생</li>
  <li>선행 테이블이 충분히 메모리에 로딩되는 크기여야 함</li>
</ul>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[옵티마이저, 인덱스, 실행 계획]]></summary></entry><entry><title type="html">SQL 활용</title><link href="http://localhost:4000/database/2023/06/09/SQL-%ED%99%9C%EC%9A%A9.html" rel="alternate" type="text/html" title="SQL 활용" /><published>2023-06-09T06:00:01+09:00</published><updated>2023-06-09T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/09/SQL%20%ED%99%9C%EC%9A%A9</id><content type="html" xml:base="http://localhost:4000/database/2023/06/09/SQL-%ED%99%9C%EC%9A%A9.html"><![CDATA[<h2 id="조인join">조인(JOIN)</h2>

<hr />

<h3 id="equi-join등가-조인">EQUI JOIN(등가 조인)</h3>

<ul>
  <li>조인은 여러 개의 릴레이션을 사용하여 새로운 릴레이션을 만드는 과정</li>
  <li>조인의 가장 기본은 테이블 간에 교집합을 만드는 것</li>
  <li>두 개의 테이블 간에 일치하는 것을 조인</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">,</span> <span class="n">DEPT</span> <span class="k">WHERE</span> <span class="n">EMP</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="o">=</span> <span class="n">DEPT</span><span class="p">.</span><span class="n">DEPTNO</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">EQUI JOIN은 '='을 사용하여 두 개의 테이블을 연결하며, 추가 조건 및 정렬 가능</code></p>

<h3 id="inner-join">INNER JOIN</h3>

<p>EQUI JOIN과 마찬가지로 ISO 표준 SQL로 INNER JOIN이 있음, INNER JOIN은 ON문을 사용하여 테이블 연결</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">DEPT</span> <span class="k">ON</span> <span class="n">EMP</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="o">=</span> <span class="n">DEPT</span><span class="p">.</span><span class="n">DEPTNO</span>
</code></pre></div></div>

<h3 id="hash-join해시-조인">HASH JOIN(해시 조인)</h3>

<ul>
  <li>해시 조인은 먼저 선행 테이블을 결정하고 선행 테이블에서 주어진 조건에 해당하는 행을 선택</li>
  <li>해당 행이 선택되면 조인 키(JOIN Key)를 기준으로 해시 함수를 사용하여 해시 테이블인 메인 메모리에 생성하고 후행 테이블에서 주어진 조건에 만족하는 행을 찾음</li>
  <li>후행 테이블의 조인 키를 사용하여 해시 함수를 적용하여 해당 버킷을 검색</li>
</ul>

<h3 id="intersect-연산">INTERSECT 연산</h3>

<p>두 개의 테이블에서 교집합을 조회(공통된 값 조회)</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">INTERSECT</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">DEPT</span>
</code></pre></div></div>

<h3 id="non-equi-join비등가-조인">Non-EQUI JOIN(비등가 조인)</h3>

<ul>
  <li>Non-EQUI는 두 개의 테이블 간에 조인하는 경우 ‘=’을 사용하지 않고 (&gt;, &lt;, &gt;=, &lt;=)등을 사용</li>
  <li>정확하게 일치하지 않는 것을 조인</li>
</ul>

<h3 id="outer-join">OUTER JOIN</h3>

<ul>
  <li>두 개의 테이블 간에 교집합(EQUI JOIN)을 조회하고 한쪽 테이블에만 있는 데이터도 포함시켜 조회</li>
  <li>왼쪽 테이블에만 있는 행을 포함하려면 <code class="language-plaintext highlighter-rouge">LEFT OUTER JOIN</code> , 오른쪽 테이블의 행을 포함하려면 <code class="language-plaintext highlighter-rouge">RIGHT OUTER JOIN</code> 을 사용</li>
  <li><code class="language-plaintext highlighter-rouge">FULL OUTER JOIN</code> 은 <code class="language-plaintext highlighter-rouge">LEFT OUTER JOIN</code> 과 <code class="language-plaintext highlighter-rouge">RIGHT OUTER JOIN</code> 모두를 하는 것</li>
  <li>Oacle 데이터베이스는 OUTER JOIN을 할 때 “(+)”기호를 사용</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">DEPT</span><span class="p">,</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">EMP</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="o">=</span> <span class="n">DEPT</span><span class="p">.</span><span class="n">DEPTNO</span>
</code></pre></div></div>

<p>위의 쿼리는 Oracle 데이터베이스의 OUTER JOIN 방법</p>

<h3 id="cross-join">CROSS JOIN</h3>

<ul>
  <li>조인 조건구 없이 2개의 테이블을 하나로 조인</li>
  <li>조인구가 없기에 카테시안 곱 발생</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">DEPT</span>
</code></pre></div></div>

<h3 id="union">UNION</h3>

<ul>
  <li>두 개의 테이블을 하나로 만드는 연산(2개의 테이블을 하나로 합치는 것)</li>
  <li>두 개의 테이블의 칼럼 수, 칼럼의 데이터 형식 모두가 일치해야 함</li>
  <li>UNION 연산이 사용될 때 칼럼 수 혹은 데이터 형식이 다르면 오류 발생</li>
  <li>테이블을 합치면서 중복된 데이터 제거</li>
  <li>정렬 과정 발생</li>
</ul>

<h3 id="union-all">UNION ALL</h3>

<ul>
  <li>두 개의 테이블을 하나로 만드는 연산</li>
  <li>중복을 제거하거나 정렬을 유발하지 않음</li>
</ul>

<h3 id="minus">MINUS</h3>

<ul>
  <li>두 개의 테이블에서 차집합을 조회</li>
  <li>MS-SQL에서는 EXCEPT 사용</li>
</ul>

<h2 id="계층형-조회connect-by">계층형 조회(CONNECT BY)</h2>

<hr />

<ul>
  <li>Oracle 데이터베이스에서 지원하며, 계층형으로 데이터를 조회할 수 있음</li>
  <li>트리(Tree) 형태의 구조로 질의를 수행</li>
  <li>START WITH는 시작 조건을 의미</li>
  <li>CONNECT BY PRIOR는 조인 조건을 의미</li>
  <li>Root 노드로부터 하위 노드의 질의를 실행</li>
  <li>MAX(LEVEL)을 사용하여 최대 계층 수를 구할 수 있음</li>
</ul>

<h3 id="connect-by-키워드">CONNECT BY 키워드</h3>

<table>
  <thead>
    <tr>
      <th>키워드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>LEVEL</td>
      <td>검색 항목의 깊이를 의미(최상위 레벨은 1)</td>
    </tr>
    <tr>
      <td>CONNECT_BY_ROOT</td>
      <td>계층 구조에서 가장 최상위 값을 표시</td>
    </tr>
    <tr>
      <td>CONNECT_BY_ISLEAF</td>
      <td>계층 구조에서 가장 최하위를 표시</td>
    </tr>
    <tr>
      <td>SYS_CONNECT_BY_PATH</td>
      <td>계층 구조의 전체 전개 경로 표시</td>
    </tr>
    <tr>
      <td>NOCYCLE</td>
      <td>순환 구조가 발생지점까지만 전개</td>
    </tr>
    <tr>
      <td>CONNECT_BY_ISCYCLE</td>
      <td>순환 구조 발생 지점 표시</td>
    </tr>
  </tbody>
</table>

<h3 id="계층형-조회-키워드">계층형 조회 키워드</h3>

<table>
  <thead>
    <tr>
      <th>키워드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>START WITH 조건</td>
      <td>계층 전개의 시작 위치를 지정</td>
    </tr>
    <tr>
      <td>PRIOR 자식 = 부모</td>
      <td>부모에서 자식방향으로 검색을 수행하는 순방향 전개</td>
    </tr>
    <tr>
      <td>PRIOR 부모 = 자식</td>
      <td>자식에서 부모방향으로 검색을 수행하는 역방향 전개</td>
    </tr>
    <tr>
      <td>NOCYCLE</td>
      <td>데이터를 전개하면서 이미 조회한 데이터를 조회하면 CYCLE이 형성되는데, 사이클이 발생되지 않게 함</td>
    </tr>
    <tr>
      <td>Order siblings by 칼럼</td>
      <td>동일한 LEVEL인 형제노드 사이에서 정렬을 수행</td>
    </tr>
  </tbody>
</table>

<h2 id="서브쿼리subquery">서브쿼리(Subquery)</h2>

<hr />

<ul>
  <li>SELECT문 내에 다시 SELECT문을 사용하는 SQL문</li>
  <li>FROM구에 SELECT문을 사용하면 인라인 뷰(Inline View)라고 함</li>
  <li>SELECT문에 서브쿼리를 사용하면 스칼라 서브쿼리(Scala Subquery)라고 함</li>
  <li>WHERE구에 SELECT문을 사용하면 서브쿼리라고 함</li>
  <li>서브쿼리 밖에 있는 SELECT문은 메인쿼리라고 함</li>
  <li>서브쿼리내에서 메인쿼리 내 칼럼을 사용하면 연관 서브쿼리(Correlated Subquery)라고 함</li>
</ul>

<h3 id="단일-행-서브쿼리와-다중-행-서브쿼리">단일 행 서브쿼리와 다중 행 서브쿼리</h3>

<ul>
  <li>단일 행 서브쿼리는 단 하나의 행만 반환하며, 비교 연산자(=, &lt;, &lt;=, &gt;, &gt;=, &lt;&gt;)를 사용</li>
  <li>다중 행 서브쿼리는 여러 행을 반환하며, IN, ANY, ALL, EXISTS를 사용</li>
</ul>

<h3 id="다중-행-비교-연산자">다중 행 비교 연산자</h3>

<table>
  <thead>
    <tr>
      <th>연산</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>IN</td>
      <td>메인쿼리의 비교조건이 서브쿼리의 결과 중 하나만 동일하면 참</td>
    </tr>
    <tr>
      <td>ALL</td>
      <td>- 메인쿼리와 서브쿼리의 결과가 모두 동일하면 참<br />- &lt; ALL: 최솟값 반환<br />- &gt; ALL: 최댓값 반환</td>
    </tr>
    <tr>
      <td>ANY</td>
      <td>- 메인쿼리의 비교조건이 서브쿼리의 결과 중 하나 이상 동일하면 참<br />- &lt; ANY: 하나라도 크면 참<br />- &gt; ANY: 하나라도 작으면 참</td>
    </tr>
    <tr>
      <td>EXISTS</td>
      <td>메인쿼리와 서브쿼리의 결과가 하나라도 존재하면 참</td>
    </tr>
  </tbody>
</table>

<h2 id="그룹-함수group-function">그룹 함수(Group Function)</h2>

<hr />

<h3 id="rollup-함수">ROLLUP 함수</h3>

<ul>
  <li>GROUP BY의 칼럼에 대해 Subtotal을 만듦</li>
  <li>ROLLUP을 할 때 GROUP BY구에 칼럼이 두 개 이상 올 시 순서에 따라 결과가 달라짐</li>
</ul>

<h3 id="grouping-함수">GROUPING 함수</h3>

<ul>
  <li>GROUPING 함수는 ROLLUP, CUBE, GROUPING SETS에서 생성되는 합계값을 구분할 수 있음</li>
  <li>GROUPING 함수의 기능을 사용하면 사용자가 필요로 하는 데이터를 SELECT문으로 작성하여 제공할 수 있음</li>
</ul>

<h3 id="grouping-sets-함수">GROUPING SETS 함수</h3>

<ul>
  <li>GROUP BY에 나오는 칼럼의 순서와 관계없이 다양한 소계를 만들 수 있음</li>
  <li>GROUP BY에 나오는 칼럼의 순서와 관계없이 개별적으로 모두 처리</li>
</ul>

<h3 id="cube-함수">CUBE 함수</h3>

<ul>
  <li>제시한 칼럼에 대해 결합 가능한 모든 집계 계산</li>
  <li>다차원 집계를 제공하여 다양하게 데이터를 분석할 수 있음</li>
  <li>조합할 수 있는 경우의 수가 모두 조합되는 것</li>
</ul>

<h2 id="윈도우-함수window-function">윈도우 함수(Window Function)</h2>

<hr />

<ul>
  <li>행과 행 간의 관계를 정의하기 위해 제공되는 함수</li>
  <li>순위, 합계, 평군, 행 위치 등을 조작할 수 있음</li>
</ul>

<h3 id="윈도우-함수-구조">윈도우 함수 구조</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">WINDOW_FUNCTION</span><span class="p">(</span><span class="n">ARGUMENTS</span><span class="p">)</span>
<span class="n">OVER</span> <span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="err">칼럼</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">WINDOWING</span><span class="err">절</span><span class="p">)</span>
<span class="k">FROM</span> <span class="err">테이블</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>구조</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ARGUMENTS(인수)</td>
      <td>윈도우 함수에 따라 0~N개의 인수 설정</td>
    </tr>
    <tr>
      <td>PARTITION BY</td>
      <td>전체 집합을 기준에 의해 소그룹으로 나눔</td>
    </tr>
    <tr>
      <td>ORDER BY</td>
      <td>어떤 항목에 대해 정렬</td>
    </tr>
    <tr>
      <td>WINDOWING</td>
      <td>행 기준의 범위 지정 (추후 설명)</td>
    </tr>
  </tbody>
</table>

<h3 id="windowing">WINDOWING</h3>

<table>
  <thead>
    <tr>
      <th>구조</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ROWS</td>
      <td>부분집합인 윈도우 크기를 물리적 단위로 행의 집합 지정</td>
    </tr>
    <tr>
      <td>RANGE</td>
      <td>논리적인 주소에 의해 행 집합 지정</td>
    </tr>
    <tr>
      <td>BETWEEN~AND</td>
      <td>윈도우의 시작과 끝의 위치를 지정</td>
    </tr>
    <tr>
      <td>UNBOUNDED PRECEDING</td>
      <td>윈도우의 시작 위치가 첫 번째 행임을 의미</td>
    </tr>
    <tr>
      <td>UNBOUNDED FOLLOWING</td>
      <td>윈도우 마지막 위치가 마지막 행임을 의미</td>
    </tr>
    <tr>
      <td>CURRENT ROW</td>
      <td>윈도우 시작 위치가 현재 행임을 의미</td>
    </tr>
  </tbody>
</table>

<h2 id="순위-함수rank-function">순위 함수(RANK Function)</h2>

<hr />

<p>특정 항목과 파티션에 대해 순위를 계산할 수 있는 함수</p>

<h3 id="순위-관련-윈도우-함수">순위 관련 윈도우 함수</h3>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>RANK()</td>
      <td>특정 항목 및 파티션에 대해 순위 계산(동일한 순위는 동일한 값 부여)</td>
    </tr>
    <tr>
      <td>DENSE_RANK()</td>
      <td>동일한 순위를 하나의 건수로 계산</td>
    </tr>
    <tr>
      <td>ROW_NUMBER()</td>
      <td>동일한 순위에 대해 고유의 순위 부여</td>
    </tr>
  </tbody>
</table>

<h2 id="집계-함수aggregate-function">집계 함수(AGGREGATE Function)</h2>

<hr />

<h3 id="집계-관련-윈도우-함수">집계 관련 윈도우 함수</h3>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SUM()</td>
      <td>파티션 별로 합계 계산</td>
    </tr>
    <tr>
      <td>AVG()</td>
      <td>파티션 별로 평균 계산</td>
    </tr>
    <tr>
      <td>COUNT()</td>
      <td>파티션 별로 행 수 계산</td>
    </tr>
    <tr>
      <td>MAX()</td>
      <td>파티션 별로 최댓값 계산</td>
    </tr>
    <tr>
      <td>MIN()</td>
      <td>파티션 별로 최솟값 계산</td>
    </tr>
  </tbody>
</table>

<h2 id="행-순서-관련-함수">행 순서 관련 함수</h2>

<hr />

<ul>
  <li>상위 행의 값을 하위에 출력하거나 하위 행의 값을 상위 행에 출력 할 수 있음</li>
  <li>특정 위치의 행을 출력할 수 있음</li>
</ul>

<h3 id="행-순서-관련-윈도우-함수">행 순서 관련 윈도우 함수</h3>

<table>
  <thead>
    <tr>
      <th>행 순서</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>FIRST_VALUE()</td>
      <td>- 파티션에서 가장 처음에 나오는 값을 구함<br />- MIN 함수를 사용해서 같은 결과를 구할 수 있음</td>
    </tr>
    <tr>
      <td>LAST_VALUE()</td>
      <td>- 파티션에서 가장 나중에 나오는 값을 구함<br />- MAX 함수를 사용해서 같은 결과를 구할 수 있음</td>
    </tr>
    <tr>
      <td>LAG()</td>
      <td>이전 행을 가져옴</td>
    </tr>
    <tr>
      <td>LEAD()</td>
      <td>윈도우에서 특정 위치의 행을 가져옴(기본값: 1)</td>
    </tr>
  </tbody>
</table>

<h2 id="비율-관련-함수">비율 관련 함수</h2>

<hr />

<h3 id="비율-관련-윈도우-함수">비율 관련 윈도우 함수</h3>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CUME_DIST()</td>
      <td>파티션 전체 건수에서 현재 행보다 작거나 같은 건수에 대한 누적 백분율 조회(0~1 사이의 값)</td>
    </tr>
    <tr>
      <td>PERCENT_RANK()</td>
      <td>파티션에서 제일 먼저 나온 것을 0으로 제일 늦게 나온 것을 1로 하여 값이 아닌 행의 순서별 백분율 조회</td>
    </tr>
    <tr>
      <td>NTILE()</td>
      <td>파티션별로 전체 건수를 ARGUMENT 값으로 N등분 한 결과 조회</td>
    </tr>
    <tr>
      <td>RATIO_TO_REPORT()</td>
      <td>파티션 내에 전체 SUM(칼럼)에 대한 행 별 칼럼 값의 백분율을 소수점까지 조회</td>
    </tr>
  </tbody>
</table>

<h2 id="테이블-파티션table-partition">테이블 파티션(Table Partition)</h2>

<hr />

<ul>
  <li>파티션은 대용량의 테이블을 여러 개의 데이터 파일에 분리하여 저장하는 기능</li>
  <li>테이블의 데이터가 물리적으로 분리된 데이터 파일에 저장되면 입력, 수정, 삭제, 조회 성능이 향상</li>
  <li>각각의 파티션 별로 독립적으로 괄리될 수 있음(파티션 별로 백업하고 복구가 가능하면 파티션 전용 인덱스 생성도 가능)</li>
  <li>데이터를 조회할 때 데이터의 범위를 줄여 성능 향상</li>
</ul>

<h3 id="파티션-기법">파티션 기법</h3>

<ul>
  <li>Range Partition: 테이블의 칼럼 중 값의 범위를 기준으로 여러 파티션으로 데이터를 나누어 저장하는 방법</li>
  <li>List Partition: 특정 값을 기준으로 분할하는 방법</li>
  <li>Hash Partition: DBMS가 내부적으로 해시 함수를 사용하여 데이터를 분할</li>
  <li>Composite Partition: 여러 개의 파티션 기법을 조합하여 사용하는 방법</li>
</ul>

<h3 id="파티션-인덱스">파티션 인덱스</h3>

<ul>
  <li>Global Index: 여러 개의 파티션에서 하나의 인덱스 사용</li>
  <li>Local Index: 파티션 별로 각자의 인덱스 사용</li>
  <li>Prefixed Index: 파티션 키와 인덱스 키가 동일</li>
  <li>Non Prefixed Index: 파티션 키와 인덱스 키가 다름</li>
</ul>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[[SQL 활용]-Join, Window Function]]></summary></entry><entry><title type="html">DCL(Data Control Language)</title><link href="http://localhost:4000/database/2023/06/08/SQL-%EA%B8%B0%EB%B3%B8-DCL.html" rel="alternate" type="text/html" title="DCL(Data Control Language)" /><published>2023-06-08T06:00:01+09:00</published><updated>2023-06-08T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/08/%5BSQL%20%EA%B8%B0%EB%B3%B8%5DDCL</id><content type="html" xml:base="http://localhost:4000/database/2023/06/08/SQL-%EA%B8%B0%EB%B3%B8-DCL.html"><![CDATA[<h2 id="grant">GRANT</h2>

<hr />

<p>데이터베이스 사용자에게 권한을 부여함</p>

<p><code class="language-plaintext highlighter-rouge">데이터베이스 사용을 위해서는 권한이 필요하며 연결, 입력, 수정, 삭제, 조회를 할 수 있음</code></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">GRANT</span> <span class="err">권한</span> <span class="k">ON</span> <span class="err">테이블</span> <span class="k">TO</span> <span class="err">사용자</span>
</code></pre></div></div>

<h3 id="권한">권한</h3>

<table>
  <thead>
    <tr>
      <th>권한</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SELECT</td>
      <td>지정된 테이블에 대해 SELCET 권한 부여</td>
    </tr>
    <tr>
      <td>INSERT</td>
      <td>지정된 테이블에 대해 INSERT 권한 부여</td>
    </tr>
    <tr>
      <td>UPDATE</td>
      <td>지정된 테이블에 대해 UPDATE 권한 부여</td>
    </tr>
    <tr>
      <td>DELETE</td>
      <td>지정된 테이블에 대해 DELETE 권한 부여</td>
    </tr>
    <tr>
      <td>REFERENCES</td>
      <td>지정된 테이블을 참조하는 제약조건을 생성하는 권한 부여</td>
    </tr>
    <tr>
      <td>ALTER</td>
      <td>지정된 테이블에 대해 ALTER 권한 부여</td>
    </tr>
    <tr>
      <td>INDEX</td>
      <td>지정된 테이블에 대해 인덱스를 생성할 수 있는 권한 부여</td>
    </tr>
    <tr>
      <td>ALL</td>
      <td>지정된 테이블에 대한 모든 권한 부여</td>
    </tr>
  </tbody>
</table>

<h3 id="with-grant-option">WITH GRANT OPTION</h3>

<ul>
  <li>특정 사용자에게 권한을 부여할 수 있는 권한 부여</li>
  <li>권한을 A 사용자가 B에 부여하고 B가 C에게 권한을 부여한 후 권한을 취소하면 모든 권한이 회수됨</li>
</ul>

<h3 id="with-admin-option">WITH ADMIN OPTION</h3>

<ul>
  <li>테이블에 대한 모든 권한 부여</li>
  <li>권한을 A 사용자가 B에 부여하고 B가 C에게 권한을 부여한 후 권한을 취소하면 B 사용자에 대한 권한만 회수됨</li>
</ul>

<h2 id="revoke">REVOKE</h2>

<hr />

<p>데이터베이스 사용자에게 부여된 권한을 회수 함</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">REVOKE</span> <span class="err">권한</span> <span class="k">ON</span> <span class="err">테이블</span> <span class="k">FROM</span> <span class="err">사용자</span>
</code></pre></div></div>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[[SQL 기본]-DCL]]></summary></entry><entry><title type="html">TCL(Transaction Control Language)</title><link href="http://localhost:4000/database/2023/06/08/SQL-%EA%B8%B0%EB%B3%B8-TCL.html" rel="alternate" type="text/html" title="TCL(Transaction Control Language)" /><published>2023-06-08T06:00:01+09:00</published><updated>2023-06-08T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/08/%5BSQL%20%EA%B8%B0%EB%B3%B8%5DTCL</id><content type="html" xml:base="http://localhost:4000/database/2023/06/08/SQL-%EA%B8%B0%EB%B3%B8-TCL.html"><![CDATA[<h2 id="commit">COMMIT</h2>

<hr />

<ul>
  <li>INSERT, UPDATE, DELETE문으로 변경한 데이터를 데이터베이스에 반영</li>
  <li>변경 이전 데이터는 잃어버림</li>
  <li>다른 모든 데이터베이스 사용자는 변경된 데이터를 볼 수 있음</li>
  <li>COMMIT이 완료되면 데이터베이스 변경으로 인한 LOCK이 해제(UNLOCK)됨</li>
  <li>COMMIT이 완료되면 다른 모든 데이터베이스 사용자는 변경된 데이터를 조작할 수 있음</li>
  <li>COMMIT을 실행하면 하나의 트랜잭션 과정을 종료함</li>
</ul>

<h2 id="rollback">ROLLBACK</h2>

<hr />

<ul>
  <li>데이터에 대한 변경 사용을 모두 취소하고 트랜잭션을 종료</li>
  <li>INSERT, UPDATE, DELETE문의 작업을 모두 취소</li>
  <li>이전에 COMMIT한 곳까지만 복구 됨</li>
  <li>ROLLBACK을 실행하면 LOCK이 해제되고 다른 사용자도 데이터베이스를 조작할 수 있음</li>
</ul>

<h2 id="savepoint">SAVEPOINT</h2>

<hr />

<ul>
  <li>트랜잭션을 작게 분할하여 관리하는 것으로 SAVEPOINT를 사용하면 지정된 위치 이후의 트랜잭션만 ROLLBACK할 수 있음</li>
  <li><code class="language-plaintext highlighter-rouge">SAVEPOINT 포인트명</code> 으로 지정할 수 있음</li>
  <li>지정된 SAVEPOINT까지의 데이터 변경을 취소하고 싶을 경우 <code class="language-plaintext highlighter-rouge">ROLLBACK TO 포인트명</code> 을 실행</li>
  <li>ROLLBACK을 실행하면 SAVEPOINT와 관계없이 데이터의 모든 변경사항을 저장하지 않음</li>
</ul>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[[SQL 기본]-TCL]]></summary></entry><entry><title type="html">DML(Data Manipulation Language)</title><link href="http://localhost:4000/database/2023/06/07/SQL-%EA%B8%B0%EB%B3%B8-DML.html" rel="alternate" type="text/html" title="DML(Data Manipulation Language)" /><published>2023-06-07T06:00:01+09:00</published><updated>2023-06-07T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/07/%5BSQL%20%EA%B8%B0%EB%B3%B8%5DDML</id><content type="html" xml:base="http://localhost:4000/database/2023/06/07/SQL-%EA%B8%B0%EB%B3%B8-DML.html"><![CDATA[<h2 id="insert">INSERT</h2>

<hr />

<p>테이블에 데이터를 입력하는 DML문</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="err">테이블</span><span class="p">(</span><span class="err">칼럼</span><span class="mi">1</span><span class="p">,</span> <span class="err">칼럼</span><span class="mi">2</span><span class="p">,</span> <span class="p">...)</span> <span class="k">VALUES</span><span class="p">(</span><span class="err">값</span><span class="mi">1</span><span class="p">,</span> <span class="err">값</span><span class="mi">2</span><span class="p">,</span> <span class="p">...)</span>
</code></pre></div></div>

<p>칼럼명은 생략이 가능하다 (칼럼의 순서를 맞춰야함)</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="err">테이블</span> <span class="k">VALUES</span><span class="p">(</span><span class="err">값</span><span class="mi">1</span><span class="p">,</span> <span class="err">값</span><span class="mi">2</span><span class="p">,</span> <span class="p">...)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">문자열을 입력하는 경우 작은따옴표(' ')를 사용해야 한다</code></p>

<p>INSERT문을 실행했다고 데이터 파일에 저장되는 것은 아님. 최종적으로 TCL문인 <code class="language-plaintext highlighter-rouge">Commit</code>을 실행해야 함</p>

<h2 id="update">UPDATE</h2>

<hr />

<p>입력된 데이터의 값을 수정할 수 있음</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="err">테이블</span> <span class="k">SET</span> <span class="err">칼럼</span><span class="o">=</span><span class="err">값</span> <span class="k">WHERE</span> <span class="err">조건</span>
</code></pre></div></div>

<p>위의 쿼리는 조건에 맞는 ROW의 칼럽을 수정하는 쿼리이다</p>

<h2 id="delete">DELETE</h2>

<hr />

<p>원하는 조건을 검색하여 해당 ROW를 삭제할 수 있음</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DELETE</span> <span class="k">FROM</span> <span class="err">테이블</span> <span class="k">WHERE</span> <span class="err">조건</span>
</code></pre></div></div>

<h3 id="테이블의-모든-데이터-삭제">테이블의 모든 데이터 삭제</h3>

<table>
  <thead>
    <tr>
      <th>DELETE FROM 테이블</th>
      <th>TRUNCATE TABLE 테이블</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>테이블의 모든 데이터를 삭제</td>
      <td>테이블의 모든 데이터 삭제</td>
    </tr>
    <tr>
      <td>데이터가 삭제되어도 테이블의 용량 감소 X</td>
      <td>데이터가 삭제되면 테이블의 용량은 초기화</td>
    </tr>
  </tbody>
</table>

<h2 id="select">SELECT</h2>

<hr />

<p>테이블에 입력된 데이터 조회</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="err">테이블</span>
</code></pre></div></div>

<p>위의 쿼리는 해당 테이블의 모든 데이터를 조회한다</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="err">테이블</span> <span class="k">WHERE</span> <span class="err">조건</span>
</code></pre></div></div>

<p>위의 쿼리는 해당 테이블에서 조건이 맞는 모든 데이터를 조회한다</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="err">칼럼</span><span class="mi">1</span><span class="p">,</span> <span class="err">칼럼</span><span class="mi">2</span> <span class="k">FROM</span> <span class="err">테이블</span>
</code></pre></div></div>

<p>위의 쿼리는 해당 테이블에서 모든 데이터의 칼럼1과 2만 조회한다</p>

<p><code class="language-plaintext highlighter-rouge">DISTINCT는 칼럼명 앞에 지정하며 중복된 데이터를 한 번만 조회함</code></p>

<h2 id="where">WHERE</h2>

<hr />

<p>WHERE문은 비교 연산자, 부정 비교 연산자, 논리 연산자, SQL 연산자, 부정 SQL 연산자를 사용할 수 있다</p>

<h3 id="비교-연산자">비교 연산자</h3>

<table>
  <thead>
    <tr>
      <th>비교 연산자</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>=</td>
      <td>같은 것을 조회</td>
    </tr>
    <tr>
      <td>&lt;</td>
      <td>작은 것을 조회</td>
    </tr>
    <tr>
      <td>&lt;=</td>
      <td>작거나 같은 것을 조회</td>
    </tr>
    <tr>
      <td>&gt;</td>
      <td>큰 것을 조회</td>
    </tr>
    <tr>
      <td>&gt;=</td>
      <td>크거나 같은 것을 조회</td>
    </tr>
  </tbody>
</table>

<h3 id="부정-비교-연산자">부정 비교 연산자</h3>

<table>
  <thead>
    <tr>
      <th>부정 비교 연산자</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>!=</td>
      <td>같지 않은 것을 조회</td>
    </tr>
    <tr>
      <td>^=</td>
      <td>같지 않은 것을 조회</td>
    </tr>
    <tr>
      <td>&lt;&gt;</td>
      <td>같지 않은 것을 조회</td>
    </tr>
    <tr>
      <td>NOT 칼럼명 =</td>
      <td>같지 않은 것을 조회</td>
    </tr>
    <tr>
      <td>NOT 칼럼명 &gt;</td>
      <td>크지 않은 것을 조회</td>
    </tr>
  </tbody>
</table>

<h3 id="논리-연산자">논리 연산자</h3>

<table>
  <thead>
    <tr>
      <th>논리 연산자</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>AND</td>
      <td>조건을 모두 만족해야 참(True)</td>
    </tr>
    <tr>
      <td>OR</td>
      <td>조건 중 하나만 만족해도 참(True)</td>
    </tr>
    <tr>
      <td>NOT</td>
      <td>참이면 거짓(False)으로 바꾸고 거짓이면 참(True)로 바꿈</td>
    </tr>
  </tbody>
</table>

<h3 id="sql-연산자">SQL 연산자</h3>

<table>
  <thead>
    <tr>
      <th>SQL 연산자</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>LIKE ‘%비교 문자열%’</td>
      <td>비교 문자열 조회 (%는 모든 값을 의미하는 와일드 카드)</td>
    </tr>
    <tr>
      <td>BETWEEN A AND B</td>
      <td>A와 B 사이의 값 조회</td>
    </tr>
    <tr>
      <td>IN (list)</td>
      <td>OR을 의미하며 list 값 중 하나만 일치해도 조회</td>
    </tr>
    <tr>
      <td>IS NULL</td>
      <td>NULL 값 조회</td>
    </tr>
  </tbody>
</table>

<h3 id="부정-sql-연산자">부정 SQL 연산자</h3>

<table>
  <thead>
    <tr>
      <th>부정 SQL 연산자</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NOT BETWEEN A AND B</td>
      <td>A와 B 사이의 해당되지 않는 값 조회</td>
    </tr>
    <tr>
      <td>NOT IN (list)</td>
      <td>list와 불일치한 것 조회</td>
    </tr>
    <tr>
      <td>IS NOT NULL</td>
      <td>NULL 값이 아닌 것 조회</td>
    </tr>
  </tbody>
</table>

<h3 id="와일드-카드">와일드 카드</h3>

<table>
  <thead>
    <tr>
      <th>와일드 카드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>%</td>
      <td>어떤 문자를 포함한 모든 것 조회</td>
    </tr>
    <tr>
      <td>_</td>
      <td>한 개인 단일 문자</td>
    </tr>
  </tbody>
</table>

<h3 id="null-관련-함수">NULL 관련 함수</h3>

<table>
  <thead>
    <tr>
      <th>NULL 함수</th>
      <th>DBMS</th>
      <th>사용법</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NVL</td>
      <td>Oracle</td>
      <td>NVL(칼럼, 값)</td>
      <td>칼럼이 NULL이면 다른 값으로 바꾸는 함수<br />예에서 칼럼이 NULL이면 값 반환</td>
    </tr>
    <tr>
      <td>NVL2</td>
      <td>Oracle</td>
      <td>NVL2(칼럼, 값1, 값2)</td>
      <td>칼럼이 NULL이 아니면 값1, NULL이면 값2 반환</td>
    </tr>
    <tr>
      <td>NULLIF</td>
      <td>Oracle, MS-SQL, MySQL</td>
      <td>NULLIF(값1, 값2)</td>
      <td>두개의 값이 같으면 NULL을, 같지 않으면 첫 번째 값 반환</td>
    </tr>
    <tr>
      <td>COALESCE</td>
      <td>Oracle, MS-SQL</td>
      <td>COALESCE(값1, 값2, … )</td>
      <td>NULL이 아닌 최초의 값 반환</td>
    </tr>
  </tbody>
</table>

<h2 id="group-연산">GROUP 연산</h2>

<hr />

<h3 id="group-by">GROUP BY</h3>

<ul>
  <li>테이블에서 소규모 행을 그룹화하여 합계, 평균, 최댓값, 최솟값 등을 계산할 수 있음</li>
  <li>HAVING 절에 조건문을 사용</li>
  <li>Grouping된 결과에 대한 조건문 사용</li>
  <li>ORDER BY를 사용하여 정렬 가능</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">DEPTNO</span>
</code></pre></div></div>

<p>위의 쿼리는 DEPTNO로 그룹을 만들어 <code class="language-plaintext highlighter-rouge">SUM(SAL)</code> 을 이용해 그룹별 합계를 계산함</p>

<h3 id="having">HAVING</h3>

<p>GROUP BY에 조건을 사용하기 위해선 HAVING을 사용해야 함</p>

<p>만약 WHERE절에 조건문을 사용하면 조건을 충족하지 못하는 데이터들은 GROUP BY 대상에서 제외</p>

<h3 id="집계함수">집계함수</h3>

<table>
  <thead>
    <tr>
      <th>집계함수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>COUNT()</td>
      <td>행 수 계산</td>
    </tr>
    <tr>
      <td>SUM()</td>
      <td>합계 계산</td>
    </tr>
    <tr>
      <td>AVG()</td>
      <td>평균 계산</td>
    </tr>
    <tr>
      <td>MAX()</td>
      <td>최댓값 계산</td>
    </tr>
    <tr>
      <td>MIN()</td>
      <td>최솟값 계산</td>
    </tr>
    <tr>
      <td>STDDEV()</td>
      <td>표준편차 계산</td>
    </tr>
    <tr>
      <td>VARIANCE()</td>
      <td>분산 계산</td>
    </tr>
  </tbody>
</table>

<h3 id="데이터-조회-실행-순서">데이터 조회 실행 순서</h3>

<ol>
  <li>SELECT</li>
  <li>FROM</li>
  <li>WHERE</li>
  <li>GROUP BY</li>
  <li>HAVING</li>
  <li>ORDER BY</li>
</ol>

<h2 id="형변환">형변환</h2>

<hr />

<p>두 개의 데이터의 데이터 타입이 일치하도록 변환하는 것</p>

<p>명시적(Explicit) 형변환과 암시적(Implicit) 형변환이 있음</p>

<h3 id="형변환-함수">형변환 함수</h3>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TO_NUMBER(문자열)</td>
      <td>문자열을 숫자로 변환</td>
    </tr>
    <tr>
      <td>TO_CHAR(숫자 혹은 날짜, FORMAT)</td>
      <td>숫자 혹은 날짜를 지정된 FORMAT의 문자로 변환</td>
    </tr>
    <tr>
      <td>TO_DATE(문자열, FORMAT)</td>
      <td>문자열을 지정된 FORMAT의 날짜형으로 변환</td>
    </tr>
  </tbody>
</table>

<h2 id="내장형-함수">내장형 함수</h2>

<hr />

<h3 id="dual-테이블">DUAL 테이블</h3>

<p>Oracle 데이터베이스에 의해 자동으로 생성되는 테이블</p>

<h3 id="문자열-함수">문자열 함수</h3>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>DBMS</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ASCII(문자)</td>
      <td> </td>
      <td>문자 혹은 숫자를 ASCII 코드값으로 변환</td>
    </tr>
    <tr>
      <td>CHR(ASCII코드)</td>
      <td>Oracle</td>
      <td>ASCII 코드값을 문자로 변환</td>
    </tr>
    <tr>
      <td>CHAR(ASCII코드)</td>
      <td>MS-SQL, MySQL</td>
      <td>ASCII 코드값을 문자로 변환</td>
    </tr>
    <tr>
      <td>SUBSTR(문자열, m, n)</td>
      <td> </td>
      <td>문자열에서 m번째 위치부터 n개 자름</td>
    </tr>
    <tr>
      <td>CONCAT(문자열1, 문자열2)</td>
      <td> </td>
      <td>문자열1과 문자열2를 결합한다</td>
    </tr>
    <tr>
      <td>LOWER(문자열)</td>
      <td> </td>
      <td>영문자를 소문자로 변환</td>
    </tr>
    <tr>
      <td>UPPER(문자열)</td>
      <td> </td>
      <td>영문자를 대문자로 변환</td>
    </tr>
    <tr>
      <td>LENGTH</td>
      <td> </td>
      <td>공백을 포함한 문자열의 길이 반환</td>
    </tr>
    <tr>
      <td>LEN(문자열)</td>
      <td> </td>
      <td>공백을 포함한 문자열의 길이 반환</td>
    </tr>
    <tr>
      <td>LTRIM(문자열, 지정문자)</td>
      <td> </td>
      <td>왼쪽에서 지정된 문자를 삭제 (지정 문자를 생략시 공백 제거)</td>
    </tr>
    <tr>
      <td>RTRIM(문자열, 지정문자)</td>
      <td> </td>
      <td>오른쪽에서 지정된 문자를 삭제 (지정 문자를 생략시 공백 제거)</td>
    </tr>
    <tr>
      <td>TRIM(문자열, 지정문자)</td>
      <td> </td>
      <td>왼쪽 및 오른쪽에서 지정된 문자를 삭제 (지정 문자를 생략시 공백 제거)</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">DBMS의 공백은 모든 DBMS가 지원하는 함수</code></p>

<h3 id="날짜형-함수">날짜형 함수</h3>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SYSDATE</td>
      <td>현재 날짜를 날짜 타입으로 반환</td>
    </tr>
    <tr>
      <td>EXTRACT(’YEAR’ | ‘MONTH’ | ‘DAY’ from dual)</td>
      <td>날짜에서 년, 월, 일을 조회</td>
    </tr>
  </tbody>
</table>

<h3 id="숫자형-함수">숫자형 함수</h3>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ABS(숫자)</td>
      <td>절댓값 반환</td>
    </tr>
    <tr>
      <td>SIGN(숫자)</td>
      <td>양수, 음수, 0을 구별</td>
    </tr>
    <tr>
      <td>MOD(숫자1, 숫자2)</td>
      <td>숫자1을 숫자2로 나누어 나머지 계산(%를 사용해도 됨)</td>
    </tr>
    <tr>
      <td>CEIL(숫자)</td>
      <td>숫자보다 크거나 같은 최소의 정수 반환</td>
    </tr>
    <tr>
      <td>CEILING(숫자)</td>
      <td>숫자보다 크거나 같은 최소의 정수 반환</td>
    </tr>
    <tr>
      <td>FLOOR(숫자)</td>
      <td>숫자보다 작거나 같은 최대의 정수 반환</td>
    </tr>
    <tr>
      <td>ROUND(숫자, m)</td>
      <td>소수점 m 자리에서 반올림 (m 생략 시 0 지정)</td>
    </tr>
    <tr>
      <td>TRUNC(숫자, m)</td>
      <td>소수점 m 자리에서 절삭 (m 생략 시 0 지정)</td>
    </tr>
  </tbody>
</table>

<h2 id="decode">DECODE</h2>

<hr />

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DECODE</span><span class="p">(</span><span class="err">칼럼</span><span class="p">,</span> <span class="err">값</span><span class="p">,</span> <span class="err">값</span><span class="mi">1</span><span class="p">,</span> <span class="err">값</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>칼럼과 값이 같으면(참) 값1을, 같지 않으면(거짓) 값2를 반환</p>

<h2 id="case">CASE</h2>

<hr />

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">CASE</span>
	<span class="k">WHEN</span> <span class="err">조건</span><span class="mi">1</span> <span class="k">THEN</span> <span class="err">값</span><span class="mi">1</span>
	<span class="k">WHEN</span> <span class="err">조건</span><span class="mi">2</span> <span class="k">THEN</span> <span class="err">값</span><span class="mi">2</span>
	<span class="k">ELSE</span> <span class="err">값</span><span class="mi">3</span>
	<span class="k">END</span>
<span class="k">FROM</span> <span class="err">테이블</span>
</code></pre></div></div>

<p>위의 쿼리는 테이블에서 맞는 조건에 따른 값 반환과 조건이 맞지 않을 시 값3을 출력한다</p>

<h2 id="rownum">ROWNUM</h2>

<hr />

<ul>
  <li>Oracle 데이터베이스의 SELECT문 결과에 대해 논리적인 일련번호를 부여함</li>
  <li>조회되는 행 수를 제한할 때 많이 사용됨</li>
  <li>화면에 데이터를 출력할 때 부여되는 논리적 순번</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">인라인 뷰(Inline view): SELCET문에서 FROM 절에 사용되는 서브쿼리(Sub Query)를 의미</code></p>

<h2 id="rowid">ROWID</h2>

<hr />

<ul>
  <li>Oracle 데이터베이스 내에서 데이터를 구불할 수 있는 유일한 값</li>
  <li>“SELECT ROWID, 갈럼 FROM 테이블” 처럼 SELECT문으로 확인할 수 있음</li>
  <li>데이터가 어떤 데이터 파일, 어느 블록에 저장되어 있는지 알 수 있음</li>
</ul>

<h3 id="rowid-구조">ROWID 구조</h3>

<table>
  <thead>
    <tr>
      <th>구조</th>
      <th>길이</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>오브젝트 번호</td>
      <td>1~6</td>
      <td>오브젝트 별로 유일한 값을 가지고 있으며, 해당 오브젝트가 속한 값</td>
    </tr>
    <tr>
      <td>상대 파일 번호</td>
      <td>7~9</td>
      <td>테이블스페이스에 속해 있는 데이터 파일에 대한 상대 파일 번호</td>
    </tr>
    <tr>
      <td>블록 번호</td>
      <td>10~15</td>
      <td>데이터 파일 내부에서 어느 블록에 데이터가 있는지 알려줌</td>
    </tr>
    <tr>
      <td>데이터 번호</td>
      <td>16~18</td>
      <td>데이터 블록에 데이터가 저장되어 있는 순서</td>
    </tr>
  </tbody>
</table>

<h2 id="with">WITH</h2>

<hr />

<ul>
  <li>서브쿼리(Subquery)를 사용하여 임시 테이블이나 뷰처럼 사용할 수 있는 구문</li>
  <li>서브쿼리 블록에 별칭을 지정할 수 있음</li>
  <li>옵티마이저는 SQL을 인라인 뷰나 임시 테이블로 판단</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WITH</span> <span class="err">임시테이블명</span> <span class="k">AS</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="err">테이블</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="err">테이블</span><span class="p">)</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="err">임시테이블명</span> <span class="k">WHERE</span> <span class="err">조건</span>
</code></pre></div></div>

<p>위의 쿼리는 WITH구문의 예</p>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[[SQL 기본]-DML]]></summary></entry><entry><title type="html">DDL(Data Definition Language)</title><link href="http://localhost:4000/database/2023/06/06/SQL-%EA%B8%B0%EB%B3%B8-DDL.html" rel="alternate" type="text/html" title="DDL(Data Definition Language)" /><published>2023-06-06T06:00:01+09:00</published><updated>2023-06-06T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/06/%5BSQL%20%EA%B8%B0%EB%B3%B8%5DDDL</id><content type="html" xml:base="http://localhost:4000/database/2023/06/06/SQL-%EA%B8%B0%EB%B3%B8-DDL.html"><![CDATA[<h2 id="sql-기본">SQL 기본</h2>

<hr />

<h3 id="sql의-종류">SQL의 종류</h3>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
      <th>구문</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>DDL(Data Definition Language)</td>
      <td>관계형 데이터베이스의 구조를 정의하는 언어</td>
      <td>CREATE, ALTER, DROP, RENAME, TRUNCATE</td>
    </tr>
    <tr>
      <td>DML(Data Manipulation Language)</td>
      <td>테이블에서 데이터를 입력, 수정, 삭제, 조회</td>
      <td>INSERT, UPDATE, DELETE, SELECT</td>
    </tr>
    <tr>
      <td>DCL(Data Control Language)</td>
      <td>데이터베이스 사용자에게 권한을 부여하거나 회수</td>
      <td>GRANT, REVOKE</td>
    </tr>
    <tr>
      <td>TCL(Transaction Control Language)</td>
      <td>트랜잭션을 제어하는 명령어</td>
      <td>COMMIT, ROLLBACK, SAVEPOINT</td>
    </tr>
  </tbody>
</table>

<h3 id="트랜잭션">트랜잭션</h3>

<p>데이터베이스의 작업을 처리하는 단위</p>

<h3 id="특징">특징</h3>

<table>
  <thead>
    <tr>
      <th>특징</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>원자성(Atomicity)</td>
      <td>- 트랜잭션은 데이터베이스 연산의 전부가 실행되거나 전혀 실행되지 않아야 함<br />- 트랜잭션의 처리가 완전히 끝나지 않았을 경우는 실행되지 않은 상태와 같아야 함</td>
    </tr>
    <tr>
      <td>일관성(Consistency)</td>
      <td>- 트랜잭션 실행 결과로 데이터베이스의 상태가 모순되지 않아야 함<br />- 트랜잭션 실행 후에도 일관성이 유지되어야 함</td>
    </tr>
    <tr>
      <td>고립성(Isolation)</td>
      <td>- 트랜잭션 실행 중에 생성하는 연산의 중간결과는 다른 트랜잭션이 접근할 수 없음<br />- 부분적인 실행 결과를 다른 트랜잭션이 볼 수 없음</td>
    </tr>
    <tr>
      <td>영속성(Durability)</td>
      <td>트랜잭션이 실행을 성공적으로 완료하면 그 결과는 영구적 보장</td>
    </tr>
  </tbody>
</table>

<h3 id="sql-실행-순서">SQL 실행 순서</h3>

<ul>
  <li>파싱(Parsing): SQL문의 문법을 확인하고 구문을 분석함(구문 분석한 SQL문은 Library Cache에 저장)</li>
  <li>실행(Execution): 옵티마이저가 수립한 실행 계획에 따라 SQL 실행</li>
  <li>인출(Fetch): 데이터를 읽어서 전송</li>
</ul>

<h2 id="테이블-생성">테이블 생성</h2>

<hr />

<h3 id="기본적인-테이블-생성">기본적인 테이블 생성</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Create</span> <span class="k">Table</span> <span class="n">EMP</span>
<span class="p">(</span>
  <span class="n">empno</span> <span class="n">number</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>   <span class="o">//</span> <span class="n">empno</span><span class="err">은</span> <span class="err">최대</span> <span class="mi">10</span><span class="err">자리</span> <span class="err">숫자로</span> <span class="err">기본키이다</span>
  <span class="n">ename</span> <span class="n">varchar2</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>    <span class="o">//</span> <span class="n">ename</span><span class="err">은</span> <span class="err">최대</span> <span class="mi">20</span><span class="err">자리의</span> <span class="err">가변</span> <span class="err">길이</span> <span class="err">문자로</span> <span class="err">공백</span> <span class="err">허용</span><span class="n">X</span>
  <span class="n">sal</span> <span class="n">number</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>                  <span class="o">//</span> <span class="n">sal</span><span class="err">은</span> <span class="err">최대</span> <span class="mi">6</span><span class="err">자리</span> <span class="err">숫자</span>
  <span class="n">createdate</span> <span class="nb">date</span> <span class="k">default</span> <span class="n">sysdate</span> <span class="o">//</span> <span class="n">createdate</span><span class="err">는</span> <span class="err">날짜를</span> <span class="err">입력받으며</span> <span class="err">기본값으로</span> <span class="err">현재</span> <span class="err">날짜</span>
<span class="p">)</span>
</code></pre></div></div>

<h2 id="제약조건">제약조건</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">제약조건은 기본키, 외래키, 기본값, not null을 테이블을 생성할 때 지정할 수 있음</code></p>

<h3 id="기본키-지정">기본키 지정</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constraint</span> <span class="err">키이름</span> <span class="k">primary</span> <span class="k">key</span><span class="p">(</span><span class="err">키이름</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="외래키-지정">외래키 지정</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constraint</span> <span class="err">외래키</span> <span class="k">foreign</span> <span class="k">key</span><span class="p">(</span><span class="err">키이름</span><span class="p">)</span> <span class="k">references</span> <span class="err">테이블</span><span class="p">(</span><span class="err">키이름</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="cascade">CASCADE</h3>

<p>CASCADE 옵션은 참조 관계가 있을 경우 참조되는 데이터를 자동으로 반영할 수 있음</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constraint</span> <span class="err">외래키</span> <span class="k">foreign</span> <span class="k">key</span><span class="p">(</span><span class="err">키이름</span><span class="p">)</span> <span class="k">references</span> <span class="err">테이블</span><span class="p">(</span><span class="err">키이름</span><span class="p">)</span> <span class="k">ON</span> <span class="k">DELETE</span> <span class="k">CASCADE</span>
</code></pre></div></div>

<p>위의 쿼리문은 자신이 참조하는 테이블의 데이터가 삭제되면 자동으로 자신도 삭제되는 옵션</p>

<h2 id="테이블-수정">테이블 수정</h2>

<hr />

<p>ALTER TABLE문을 통해 테이블명 변경, 칼럼 추가, 변경, 삭제 등을 할 수 있다.</p>

<h3 id="테이블명-변경">테이블명 변경</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">기존테이블명</span> <span class="k">TO</span> <span class="err">새로운테이블명</span>
</code></pre></div></div>

<h3 id="칼럼-추가">칼럼 추가</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">테이블명</span> <span class="k">ADD</span><span class="p">(</span><span class="err">칼럼명</span> <span class="err">자료형</span> <span class="err">조건</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="칼럼-변경">칼럼 변경</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">테이블명</span> <span class="k">MODIFY</span><span class="p">(</span><span class="err">칼럼명</span> <span class="err">자료형</span> <span class="err">조건</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="칼럼-삭제">칼럼 삭제</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">테이블명</span> <span class="k">DROP</span> <span class="k">COLUMN</span> <span class="err">칼럼명</span>
</code></pre></div></div>

<h3 id="칼럼명-변경">칼럼명 변경</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">테이블명</span> <span class="k">RENAME</span> <span class="k">COLUMN</span> <span class="err">칼럼명</span> <span class="k">to</span> <span class="err">새로운칼럼명</span>
</code></pre></div></div>

<h2 id="테이블-삭제">테이블 삭제</h2>

<hr />

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DROP</span> <span class="k">TABLE</span> <span class="err">테이블명</span>
</code></pre></div></div>

<h2 id="뷰view-생성과-삭제">뷰(VIEW) 생성과 삭제</h2>

<hr />

<ul>
  <li>뷰는 테이블로부터 유도된 가상의 테이블</li>
  <li>실제 데이터를 가지고 있지 않고테이블을 참조해 원하는 칼럼만을 조죄할 수 있음</li>
  <li>뷰는 데이터 딕셔너리(Data Dictionary)에 SQL문 형태로 저장하되 실행 시 참조됨</li>
</ul>

<h3 id="뷰의-특징">뷰의 특징</h3>

<ul>
  <li>참조한 테이블이 변경되면 뷰도 변경됨</li>
  <li>뷰의 검색은 참조한 테이블과 동일하게 할 수 있지만, 뷰에 대한 입력, 수정, 삭제에는 제약이 있음</li>
  <li>특정 칼럼만 조회시켜 보안성을 향상시킴</li>
  <li>한번 생성된 뷰는 변경할 수  없고 변경을 원하면 삭제 후 재생성해야 함</li>
  <li>ALTER문을 사용하여 뷰를 변경할 수 없음</li>
</ul>

<h3 id="생성">생성</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">VIEW</span> <span class="err">뷰이름</span> <span class="k">AS</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="err">테이블</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">뷰의 조회는 SELECT문을 사용하여 일반 테이블처럼 조회함</code></p>

<h3 id="삭제">삭제</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DROP</span> <span class="k">VIEW</span> <span class="err">뷰이름</span>
</code></pre></div></div>

<h3 id="장점">장점</h3>

<ul>
  <li>특정 칼럼만 조회할 수 있기에 보안 기능이 있음</li>
  <li>데이터 관리가 간단</li>
  <li>SELECT문이 간단해짐</li>
  <li>하나의 테이블에 여러 뷰를 생성할 수 있음</li>
</ul>

<h3 id="단점">단점</h3>

<ul>
  <li>뷰는 독자적인 인덱스를 만들 수 없음</li>
  <li>삽입, 수정, 삭제 연산이 제약됨</li>
  <li>데이터 구조를 변경할 수 없음</li>
</ul>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[[SQL 기본]-DDL]]></summary></entry><entry><title type="html">정규화</title><link href="http://localhost:4000/database/2023/06/05/%EC%A0%95%EA%B7%9C%ED%99%94.html" rel="alternate" type="text/html" title="정규화" /><published>2023-06-05T06:00:01+09:00</published><updated>2023-06-05T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/05/%EC%A0%95%EA%B7%9C%ED%99%94</id><content type="html" xml:base="http://localhost:4000/database/2023/06/05/%EC%A0%95%EA%B7%9C%ED%99%94.html"><![CDATA[<h2 id="정규화normalization">정규화(Normalization)</h2>

<hr />

<ul>
  <li>데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이며 데이터를 분해하는 과정</li>
  <li>중복을 제거하고 데이터 모델의 독립성을 확보하기 위한 방법</li>
  <li>테이블을 분해해서 데이터 중복을 제거하기 때문에 데이터 모델의 유연성을 높임</li>
  <li>정규화 수행시 비즈니스에 변화가 발생하여도 데이터 모델의 변경을 최소화할 수 있음</li>
  <li>제1정규화부터 제5정규화까지 있지만, 실질적으로 제3정규화까지만 수행</li>
</ul>

<h3 id="정규화-절차">정규화 절차</h3>

<table>
  <thead>
    <tr>
      <th>정규화 절차</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>제1정규화</td>
      <td>- 속성의 원자성 확보<br />- 기본키 설정</td>
    </tr>
    <tr>
      <td>제2정규화</td>
      <td>- 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거(분해)<br />- 기본키가 하나의 칼럼으로 이루어지면 제2정규화는 생략</td>
    </tr>
    <tr>
      <td>제3정규화</td>
      <td>- 기본키를 제외한 칼럼 간에 종속성을 제거<br />- 이행 함수 종속성을 제거</td>
    </tr>
    <tr>
      <td>BCNF</td>
      <td>기본키를 제외하고 후보키가 있는 경우, 후보키가 기본키를 종속시키면 분해</td>
    </tr>
    <tr>
      <td>제4정규화</td>
      <td>여러 칼럼들이 하나의 칼럼을 종속시키는 경우 분해하여 다중값 종속성 제거</td>
    </tr>
    <tr>
      <td>제5정규화</td>
      <td>조인에 의해 종속성이 발생되는 경우 분해</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">정규화의 문제점: 정규화는 데이터 조회(SELECT) 시에 조인(Join)을 유발하기에 CPU와 메모리를 많이 사용.</code></p>

<h2 id="반정규화de-normalization">반정규화(De-Normalization)</h2>

<hr />

<p>데이터베이스의 성능 향상을 위해 데티어 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법</p>

<p>조회(SELECT) 속도를 향상하지만, 데이터 모델의 유연성은 낮아짐</p>

<h3 id="반정규화를-수행하는-경우">반정규화를 수행하는 경우</h3>

<ul>
  <li>정규화에 충실하면 종속성, 활용성은 향상되지만 숙도가 느려지는 경우</li>
  <li>다량의 범위를 자주 처리해야 하는 경우</li>
  <li>특정 범위의 데이터만 자주 처리하는 경우</li>
  <li>요약/집계 정보가 자주 요구되는 경우</li>
</ul>

<h3 id="반정규화-절차">반정규화 절차</h3>

<ul>
  <li>대상 조사 및 검토: 데이터 처리 범위, 통계성 등을 확인해서 반정규화 대상 조사</li>
  <li>다른 방법 검토: 반정규화를 수행하기 전에 다른 방법이 있는지 검토(클러스터링, 뷰, 인덱스 튜닝, 응용프로그램, 파티션 검토)</li>
  <li>반정규화 수행: 테이블, 속성, 관계 등을 반정규화</li>
</ul>

<h3 id="반정규화-기법">반정규화 기법</h3>

<ul>
  <li>계산된 칼럼 추가</li>
  <li>테이블 수직 분할: 하나의 테이블을 두 개 이상의 테이블로 분할 (칼럼을 분할하여 새로운 테이블 생성)</li>
  <li>테이블 수평 분할: 하나의 테이블에 있는 값을 기준으로 테이블 분할</li>
  <li>테이블 병합: 테이블을 하나의 테이블로 병합하여 성능 향상</li>
</ul>

<h3 id="파티션partition-기법">파티션(Partition) 기법</h3>

<p>데이터베이스에서 파티션을 사용하여 테이블을 분할할 수 있음.</p>

<p>파티션을 사용하면 논리적으로는 하나의 테이블이지만 여러 개의 데이터 파일에 분산되어 저장됨.</p>

<table>
  <thead>
    <tr>
      <th>기법</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Range Partition</td>
      <td>데이터 값의 범위를 기준으로 파티션 수행</td>
    </tr>
    <tr>
      <td>List Partition</td>
      <td>특정한 값을 지정하여 파티션 수행</td>
    </tr>
    <tr>
      <td>Hash Partition</td>
      <td>해시 함수를 적용하여 파티션 수행</td>
    </tr>
    <tr>
      <td>Composite Partition</td>
      <td>범위와 해시를 복합적으로 사용하여 파티션 수행</td>
    </tr>
  </tbody>
</table>

<p>파티션 테이블의 장점</p>

<ul>
  <li>데이터 조회 시 액세스 범위가 줄어들기에 성능 향상</li>
  <li>데이터가 분할되어 있기에 I/O(Input/Output)의 성능 향상</li>
  <li>각 파티션을 독립적으로 백업 및 복구 가능</li>
</ul>

<h3 id="테이블-병합">테이블 병합</h3>

<ul>
  <li>1대1 관계의 테이블을 하나의 테이블로 병합하여 성능 향상</li>
  <li>1대N 관계의 테이블을 병합하여 성능 향상, 많은 양의 데이터 중복이 발생</li>
  <li>슈퍼 타입과 서브 타입 관계가 발생하면 테이블을 통합하여 성능 향상</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Super Type, Sub Type: 엔터티에 중복되는 값을 상속 Super Type은 부모, Sub Type은 자식으로 생각하면 됨</code></p>

<h3 id="슈퍼-타입-및-서브-타입-변환-방법">슈퍼 타입 및 서브 타입 변환 방법</h3>

<table>
  <thead>
    <tr>
      <th>변환 방법</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>OneToOne Type</td>
      <td>- 슈퍼 타입과 서브 타입을 개별 테이블로 도출<br />- 테이블의 수가 많아서 조인이 많이 발생하고 관리가 어려움</td>
    </tr>
    <tr>
      <td>Plus Type</td>
      <td>- 슈퍼 타입과 서브 타입 테이블로 도출<br />- 조인이 발생하고 관리가 어려움</td>
    </tr>
    <tr>
      <td>Single Type</td>
      <td>- 슈퍼 타입과 서브 타입을 하나의 테이블로 도출<br />- 조인 성능이 좋고 관리가 편하지만, 입출력 성능이 나쁨</td>
    </tr>
  </tbody>
</table>

<h2 id="분산-데이터베이스">분산 데이터베이스</h2>

<hr />

<ul>
  <li>중앙 집중형 데이터베이스: 한 대의 물리적 시스템에 DBMS를 설치하고 여러 명의 사용자가 DBMS에 접속하여 데이터베이스를 사용하는 구조</li>
  <li>분산 데이터베이스: 물리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스 이미지를 보여 주고 분산된 작업 처리를 수행하는 데이터베이스</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">DBMS: 데이터베이스 관리 시스템</code></p>

<h3 id="분산-데이터베이스의-투명성">분산 데이터베이스의 투명성</h3>

<table>
  <thead>
    <tr>
      <th>투명성</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>분할 투명성</td>
      <td>고객은 하나의 논리적 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 여러 시스템에 저장되어 있을을 인식할 필요가 없음</td>
    </tr>
    <tr>
      <td>위치 투명성</td>
      <td>- 고객이 사용하려는 데이터의 저장 장소를 명시할 필요가 없음<br />- 고객은 데이터가 어느 위치에 있더라도 동일한 명령을 사용하여 데이터에 접근할 수 있어야 함</td>
    </tr>
    <tr>
      <td>지역 사상 투명성</td>
      <td>지역 DBMS와 물리적 데이터베이스 사이의 사상이 보장됨에 따라 각 지역 시스템 이름과 무관한 이름이 사용 가능</td>
    </tr>
    <tr>
      <td>중복 투명성</td>
      <td>데이터베이스 객체가 여러 시스템에 중복되어 존재함에도 고객과는 무관하게 데이터 일관성이 유지</td>
    </tr>
    <tr>
      <td>장애 투명성</td>
      <td>데이터베이스가 분산되어 있는 각 지역의 시스템이나 통신망에 이상이 발생해도, 데이터의 무결성은 보장</td>
    </tr>
    <tr>
      <td>병행 투명성</td>
      <td>여러 고객의 응용 프로그램이 동시에 분산 데이터베이스에 대한 트랜잭션을 수행하는 경우에도 결과에 이상이 없음</td>
    </tr>
  </tbody>
</table>

<h3 id="분산-데이터베이스-설계-방식">분산 데이터베이스 설계 방식</h3>

<ul>
  <li>상향식 설계 방식: 지역 스키마 작성 후 향후 전역 스키마를 작성하여 분산 데이터베이스 구축</li>
  <li>하향식 설계 방식: 전역 스키마 작성 후 해당 지역 사상 스키마를 작성하여 분산 데이터베이스 구축</li>
</ul>

<h3 id="분산-데이터베이스-장점과-단점">분산 데이터베이스 장점과 단점</h3>

<p>장점</p>

<ul>
  <li>데이터베이스 신뢰성과 가용성이 높음</li>
  <li>분산 데이터베이스가 병렬 처리를 수행하기에 빠른 응답 가능</li>
  <li>분산 데이터베이스를 추가하여 시스템 용량 확장이 쉬움</li>
</ul>

<p>단점</p>

<ul>
  <li>데이터베이스가 여러 네트워크를 통해 분리되어 있기에 관리와 통제가 어려움</li>
  <li>보안관리가 어려움</li>
  <li>데이터 무결성 관리가 어려움</li>
  <li>데이터베이스 설계가 복잡</li>
</ul>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[데이터 베이스 정규화 작업]]></summary></entry><entry><title type="html">데이터 모델링</title><link href="http://localhost:4000/database/2023/06/04/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81.html" rel="alternate" type="text/html" title="데이터 모델링" /><published>2023-06-04T06:00:01+09:00</published><updated>2023-06-04T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/04/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81</id><content type="html" xml:base="http://localhost:4000/database/2023/06/04/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81.html"><![CDATA[<h2 id="데이터-모델링">데이터 모델링</h2>

<hr />

<p>현실 세계를 데이터베이스로 표현하기 위해 추상화하는 작업</p>

<h3 id="데이터-모델링의-특징">데이터 모델링의 특징</h3>

<table>
  <thead>
    <tr>
      <th>특징</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>추상화(Abstraction)</td>
      <td>현실 세계를 간략하게 표현한다.</td>
    </tr>
    <tr>
      <td>단순화(Simplification)</td>
      <td>누구나 쉽게 이해할 수 있도록 표현한다.</td>
    </tr>
    <tr>
      <td>명확성(Clarity)</td>
      <td>명확하게 의미가 해석되어야 하고 한 가지 의미를 가져야 한다.</td>
    </tr>
  </tbody>
</table>

<h3 id="데이터-모델링-단계">데이터 모델링 단계</h3>

<table>
  <thead>
    <tr>
      <th>데이터 모델링 단계</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>개념적 모델링</td>
      <td>- 전사적 관점에서 기업의 데이터를 모델링<br />- 추상화 수준이 가장 높은 수준의 모델링<br />- 계층형 데이터 모델, 네트워크 모델, 관계형 모델에 관계없이 업무 측면에서 모델링</td>
    </tr>
    <tr>
      <td>논리적 모델링</td>
      <td>- 특정 데이터베이스 모델에 종속<br />- 식별자를 정의하고 관계, 속성 등을 모두 표현<br />- 정규화를 통해 재사용성을 높임</td>
    </tr>
    <tr>
      <td>물리적 모델링</td>
      <td>- 구축할 데이터베이스 관리 시스템에 테이블, 인덱스 등을 생성하는 단계<br />- 성능, 보안, 가용성 등을 고려하여 데이터베이스 구축</td>
    </tr>
  </tbody>
</table>

<h3 id="데이터-모델링-관점">데이터 모델링 관점</h3>

<ul>
  <li>데이터: 비즈니스 프로세스에서 사용되는 데이터</li>
  <li>프로세스: 비즈니스 프로세스에서 수행하는 작업</li>
  <li>데이터와 프로세스: 프로세스와 데이터 간의 관계</li>
</ul>

<h3 id="erd-작성-절차">ERD 작성 절차</h3>

<ol>
  <li>엔터티를 도출하고 그림</li>
  <li>엔터티를 배치</li>
  <li>엔터티 간의 관계 설정</li>
  <li>관계명 서술</li>
  <li>관계 참여도 표현</li>
  <li>관계의 필수 여부 표현</li>
</ol>

<h3 id="3층-스키마-구조">3층 스키마 구조</h3>

<ul>
  <li>외부 스키마: 사용자 관점으로 응용 프로그램이 접근하는 데이터베이스 정의</li>
  <li>개념 스키마: 설계자 관점으로 통합 데이터베이스 구조</li>
  <li>내부 스키마: 개발자 관점으로 데이터베이스의 물리적 저장 구조</li>
</ul>

<h3 id="엔터티-특징">엔터티 특징</h3>

<ul>
  <li>식별자: 엔터티는 유일한 식별자가 있어야 한다.</li>
  <li>인스턴스 집합: 2개 이상의 인스턴스가 있어야 한다.</li>
  <li>속성: 엔터티는 반드시 속성을 가지고 있다.</li>
  <li>관계: 엔터티는 다른 엔터티와 최소한 한 개 이상 관계가 있어야 한다.</li>
  <li>업무: 엔터티는 업무에서 관리되어야 하는 집합이다.</li>
</ul>

<h2 id="엔터티-종류">엔터티 종류</h2>

<hr />

<p>엔터티의 종류는 유형, 무형에 따른 종류, 엔터티가 발생하는 시점에 따른 종류로 나누어 짐</p>

<h3 id="유형과-무형에-따른-엔터티">유형과 무형에 따른 엔터티</h3>

<ul>
  <li>유형 엔터티: 업무에서 도출되며 지속적으로 사용되는 엔터티</li>
  <li>개념 엔터티: 유형 엔터티는 물리적 형태가 있지만, 개념 엔터티는 물리적 형태가 없음</li>
  <li>사건 엔터티: 비즈니스 프로세스를 실행하면서 생성되는 엔터티</li>
</ul>

<h3 id="발생-시점에-따른-엔터티-종류">발생 시점에 따른 엔터티 종류</h3>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>기본 엔터티</td>
      <td>-키 엔터티<br />- 다른 엔터티로부터 영향을 받지 않고 독립적으로 생성되는 엔터티</td>
    </tr>
    <tr>
      <td>중심 엔터티</td>
      <td>- 기본 엔터티와 행위 엔터티 간의 중간에 있는 것<br />- 기본 엔터티로부터 발생되고 행위 엔터티를 생성하는 것</td>
    </tr>
    <tr>
      <td>행위 엔터티</td>
      <td>- 2개 이상의 엔터티로부터 발생</td>
    </tr>
  </tbody>
</table>

<h2 id="속성attribute">속성(Attribute)</h2>

<hr />

<p>엔터티가 가지는 항목</p>

<h3 id="특징">특징</h3>

<ul>
  <li>업무에서 관리되는 정보</li>
  <li>하나의 값만 가짐</li>
  <li>주식별자에게 함수적으로 종속(기본키 변경시 속성 값도 변경)</li>
</ul>

<h3 id="종류">종류</h3>

<h3 id="분해-여부에-따른-속성의-종류">분해 여부에 따른 속성의 종류</h3>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>단일 속성</td>
      <td>하나의 의미로 구성된 것</td>
    </tr>
    <tr>
      <td>복합 속성</td>
      <td>여러 개의 의미가 있는 것</td>
    </tr>
    <tr>
      <td>다중값 속성</td>
      <td>속성에 여러 개의 값을 가질 수 있는 것</td>
    </tr>
  </tbody>
</table>

<h3 id="특성에-따른-속성의-종류">특성에 따른 속성의 종류</h3>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>기본 속성</td>
      <td>비즈니스 프로세스에서 도출되는 본래의 속성</td>
    </tr>
    <tr>
      <td>설계 속성</td>
      <td>데이터 모델링 과정에서 발생되는 속성, 유일한 값을 부여</td>
    </tr>
    <tr>
      <td>파생 속성</td>
      <td>다른 속성에 의해서 만들어지는 속성</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">도메인: 속성이 가질 수 있는 값의 범위</code></p>

<h2 id="관계relationship">관계(Relationship)</h2>

<hr />

<p>엔터티 간의 관련성</p>

<h3 id="관계의-종류">관계의 종류</h3>

<ul>
  <li>존재 관계: 엔터티 간의 상태를 의미</li>
  <li>행위 관계: 엔터티 간에 어떠한 행위가 있는 것</li>
</ul>

<h3 id="관계-차수">관계 차수</h3>

<p>두 개의 엔터티 간에 관계에 참여하는 수를 의미</p>

<h3 id="관계-차수-종류">관계 차수 종류</h3>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1대1 관계</td>
      <td>완전 1대1: 하나의 엔터티에 관계되는 엔터티의 관계가 하나인 경우로, 반드시 존재<br />선택적 1대1: 하나의 엔터티에 관계되는 엔터티의 관계가 하나이거나 없을 수도 있음</td>
    </tr>
    <tr>
      <td>1대N 관계</td>
      <td>엔터티에 행이 하나 있을 때 다른 엔터티의 값이 여러 개 있는 관계</td>
    </tr>
    <tr>
      <td>M대N 관계</td>
      <td>두 개 엔터티가 서로 여러 개의 관계를 가지고 있는 것</td>
    </tr>
    <tr>
      <td>필수적, 선택적 관계</td>
      <td>필수적 관계: 반드시 하나가 있어야 하는 관계<br />선택적 관계: 없을 수도 있는 관계</td>
    </tr>
  </tbody>
</table>

<h3 id="식별-관계와-비식별-관계">식별 관계와 비식별 관계</h3>

<p>식별 관계: 강한 개체의 기본키를 다른 엔터티의 기본키로 가지는 것</p>

<p>강한 개체(Strong Entity)</p>
<ul>
  <li>어떤 다른 엔터티에게 의존하지 않고 독립적으로 존재</li>
  <li>다른 엔터티와 관계를 가질 때 다른 엔터티에게 기본키를 공유함</li>
  <li>식별 관계로 표현</li>
  <li>기본키 값이 변경되면 식별 관계(기본키를 공유받은)에 있는 엔터티의 값도 변경</li>
  <li>강한 텐터티와 관계를 갖는 엔터티는 약한 개체(Weak Entity)가 됨</li>
</ul>

<p>비식별 관계: 강한 개체의 기본키를 다른 엔터티의 기본키가 아닌 일반 칼럼으로 관계를 가지는 것</p>

<h2 id="엔터티-식별자">엔터티 식별자</h2>
<hr />
<p>엔터티를 대표할 수 있는 유일성을 만족하는 속성</p>

<h3 id="키의-종류">키의 종류</h3>
<ul>
  <li>기본키(Primary key): 후보키 중에서 엔터티를 대표할 수 있는 키</li>
  <li>후보키(Candidate key): 유일성과 최소성을 만족하는 키</li>
  <li>슈퍼키(Super key): 유일성은 만족하지만 최소성을 만족하지 않는 키</li>
  <li>대체키(Alternate key): 여러 개의 후보키 중에서 기본키를 선정하고 남은 키</li>
  <li>외래키(Foreign key): 하나 혹은 다수의 다른 테이블의 기본 키 필드를 가리키는 것으로 참조 무결성을 확인하기 위해 사용되는 키</li>
</ul>

<h3 id="주식별자기본키-primary-key">주식별자(기본키, Primary key)</h3>
<ul>
  <li>최소성: 최소성을 만족하는 키</li>
  <li>대표성: 엔터티를 대표할 수 있어야 함</li>
  <li>유일성: 엔터티의 인스턴스를 유일하게 식별 가능</li>
  <li>불변성: 자주 변경되지 않아야 함</li>
</ul>

<h3 id="실별자의-종류">실별자의 종류</h3>
<p>식별자는 대표성, 생성 여부, 속성의 수, 대체 여부로 분류</p>

<h3 id="대표성-여부에-따른-식별자의-종류">대표성 여부에 따른 식별자의 종류</h3>
<ul>
  <li>주식별자: 유일성과 최소성을 만족하면서 엔터티를 대표하는 식별자로, 다른 엔터티와 참조 관계로 연결될 수 있음</li>
  <li>보조 식별자: 유일성과 최소성은 만족하지만 대표성을 만족하지 못하는 식별자</li>
</ul>

<h3 id="생성-여부에-따른-식별자의-종류">생성 여부에 따른 식별자의 종류</h3>
<ul>
  <li>내부 식별자: 엔터티 내부에서 스스로 생성되는 식별자</li>
  <li>외부 식별자: 다른 엔터티와의 관계로 인해 만들어지는 식별자</li>
</ul>

<h3 id="속성의-수에-따른-식별자의-종류">속성의 수에 따른 식별자의 종류</h3>
<ul>
  <li>단일 식별자: 하나의 속성으로 구성</li>
  <li>복합 식별자: 두 개 이상의 속성으로 구성</li>
</ul>

<h3 id="대체-여부에-따른-식별자의-종류">대체 여부에 따른 식별자의 종류</h3>
<ul>
  <li>본질 식별자: 비즈니스 프로세스에서 만들어지는 식별자</li>
  <li>인조 식별자: 인위적으로 만들어지는 식별자</li>
</ul>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[데이터 모델링 개념]]></summary></entry></feed>