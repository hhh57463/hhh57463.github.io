<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-06-10T03:29:52+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Mindol</title><subtitle>Mindol&apos;s Blog</subtitle><author><name>Mindol</name></author><entry><title type="html">SQL 활용</title><link href="http://localhost:4000/database/2023/06/09/SQL-%ED%99%9C%EC%9A%A9.html" rel="alternate" type="text/html" title="SQL 활용" /><published>2023-06-09T06:00:01+09:00</published><updated>2023-06-09T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/09/SQL%20%ED%99%9C%EC%9A%A9</id><content type="html" xml:base="http://localhost:4000/database/2023/06/09/SQL-%ED%99%9C%EC%9A%A9.html"><![CDATA[<h1 id="sql-활용">SQL 활용</h1>

<hr />

<h2 id="조인join">조인(JOIN)</h2>

<hr />

<h3 id="equi-join등가-조인">EQUI JOIN(등가 조인)</h3>

<ul>
  <li>조인은 여러 개의 릴레이션을 사용하여 새로운 릴레이션을 만드는 과정</li>
  <li>조인의 가장 기본은 테이블 간에 교집합을 만드는 것</li>
  <li>두 개의 테이블 간에 일치하는 것을 조인</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">EMP</span><span class="p">,</span> <span class="n">DEPT</span> <span class="k">WHERE</span> <span class="n">EMP</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="o">=</span> <span class="n">DEPT</span><span class="p">.</span><span class="n">DEPTNO</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">EQUI JOIN은 '='을 사용하여 두 개의 테이블을 연결하며, 추가 조건 및 정렬 가능</code></p>

<h3 id="inner-join">INNER JOIN</h3>

<p>EQUI JOIN과 마찬가지로 ISO 표준 SQL로 INNER JOIN이 있음, INNER JOIN은 ON문을 사용하여 테이블 연결</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">DEPT</span> <span class="k">ON</span> <span class="n">EMP</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="o">=</span> <span class="n">DEPT</span><span class="p">.</span><span class="n">DEPTNO</span>
</code></pre></div></div>

<h3 id="hash-join해시-조인">HASH JOIN(해시 조인)</h3>

<ul>
  <li>해시 조인은 먼저 선행 테이블을 결정하고 선행 테이블에서 주어진 조건에 해당하는 행을 선택</li>
  <li>해당 행이 선택되면 조인 키(JOIN Key)를 기준으로 해시 함수를 사용하여 해시 테이블인 메인 메모리에 생성하고 후행 테이블에서 주어진 조건에 만족하는 행을 찾음</li>
  <li>후행 테이블의 조인 키를 사용하여 해시 함수를 적용하여 해당 버킷을 검색</li>
</ul>

<h3 id="intersect-연산">INTERSECT 연산</h3>

<p>두 개의 테이블에서 교집합을 조회(공통된 값 조회)</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">EMP</span>
<span class="k">INTERSECT</span>
<span class="k">SELECT</span> <span class="n">DEPTNO</span> <span class="k">FROM</span> <span class="n">DEPT</span>
</code></pre></div></div>

<h3 id="non-equi-join비등가-조인">Non-EQUI JOIN(비등가 조인)</h3>

<ul>
  <li>Non-DQUI는 두 개의 테이블 간에 조인하는 경우 ‘=’을 사용하지 않고 (&gt;, &lt;, ≥, ≤)등을 사용</li>
  <li>정확하게 일치하지 않는 것을 조인</li>
</ul>

<h3 id="outer-join">OUTER JOIN</h3>

<ul>
  <li>두 개의 테이블 간에 교집합(EQUI JOIN)을 조회하고 한쪽 테이블에만 있는 데이터도 포함시켜 조회</li>
  <li>왼쪽 테이블에만 있는 행을 포함하려면 <code class="language-plaintext highlighter-rouge">LEFT OUTER JOIN</code> , 오른쪽 테이블의 행을 포함하려면 <code class="language-plaintext highlighter-rouge">RIGHT OUTER JOIN</code> 을 사용</li>
  <li><code class="language-plaintext highlighter-rouge">FULL OUTER JOIN</code> 은 <code class="language-plaintext highlighter-rouge">LEFT OUTER JOIN</code> 과 <code class="language-plaintext highlighter-rouge">RIGHT OUTER JOIN</code> 모두를 하는 것</li>
  <li>Oacle 데이터베이스는 OUTER JOIN을 할 때 “(+)”기호를 사용</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">DEPT</span><span class="p">,</span> <span class="n">EMP</span> <span class="k">WHERE</span> <span class="n">EMP</span><span class="p">.</span><span class="n">DEPTNO</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span><span class="o">=</span> <span class="n">DEPT</span><span class="p">.</span><span class="n">DEPTNO</span>
</code></pre></div></div>

<p>위의 쿼리는 Oracle 데이터베이스의 OUTER JOIN 방법</p>

<h3 id="cross-join">CROSS JOIN</h3>

<ul>
  <li>조인 조건구 없이 2개의 테이블을 하나로 조인</li>
  <li>조인구가 없기에 카테시안 곱 발생</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">DEPT</span>
</code></pre></div></div>

<h3 id="union">UNION</h3>

<ul>
  <li>두 개의 테이블을 하나로 만드는 연산(2개의 테이블을 하나로 합치는 것)</li>
  <li>두 개의 테이블의 칼럼 수, 칼럼의 데이터 형식 모두가 일치해야 함</li>
  <li>UNION 연산이 사용될 때 칼럼 수 혹은 데이터 형식이 다르면 오류 발생</li>
  <li>테이블을 합치면서 중복된 데이터 제거</li>
  <li>정렬 과정 발생</li>
</ul>

<h3 id="union-all">UNION ALL</h3>

<ul>
  <li>두 개의 테이블을 하나로 만드는 연산</li>
  <li>중복을 제거하거나 정렬을 유발하지 않음</li>
</ul>

<h3 id="minus">MINUS</h3>

<ul>
  <li>두 개의 테이블에서 차집합을 조회</li>
  <li>MS-SQL에서는 EXCEPT 사용</li>
</ul>

<h2 id="계층형-조회connect-by">계층형 조회(CONNECT BY)</h2>

<hr />

<ul>
  <li>Oracle 데이터베이스에서 지원하며, 계층형으로 데이터를 조회할 수 있음</li>
  <li>트리(Tree) 형태의 구조로 질의를 수행</li>
  <li>START WITH는 시작 조건을 의미</li>
  <li>CONNECT BY PRIOR는 조인 조건을 의미</li>
  <li>Root 노드로부터 하위 노드의 질의를 실행</li>
  <li>MAX(LEVEL)을 사용하여 최대 계층 수를 구할 수 있음</li>
</ul>

<h3 id="connect-by-키워드">CONNECT BY 키워드</h3>

<table>
  <thead>
    <tr>
      <th>키워드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>LEVEL</td>
      <td>검색 항목의 깊이를 의미(최상위 레벨은 1)</td>
    </tr>
    <tr>
      <td>CONNECT_BY_ROOT</td>
      <td>계층 구조에서 가장 최상위 값을 표시</td>
    </tr>
    <tr>
      <td>CONNECT_BY_ISLEAF</td>
      <td>계층 구조에서 가장 최하위를 표시</td>
    </tr>
    <tr>
      <td>SYS_CONNECT_BY_PATH</td>
      <td>계층 구조의 전체 전개 경로 표시</td>
    </tr>
    <tr>
      <td>NOCYCLE</td>
      <td>순환 구조가 발생지점까지만 전개</td>
    </tr>
    <tr>
      <td>CONNECT_BY_ISCYCLE</td>
      <td>순환 구조 발생 지점 표시</td>
    </tr>
  </tbody>
</table>

<h3 id="계층형-조회-키워드">계층형 조회 키워드</h3>

<table>
  <thead>
    <tr>
      <th>키워드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>START WITH 조건</td>
      <td>계층 전개의 시작 위치를 지정</td>
    </tr>
    <tr>
      <td>PRIOR 자식 = 부모</td>
      <td>부모에서 자식방향으로 검색을 수행하는 순방향 전개</td>
    </tr>
    <tr>
      <td>PRIOR 부모 = 자식</td>
      <td>자식에서 부모방향으로 검색을 수행하는 역방향 전개</td>
    </tr>
    <tr>
      <td>NOCYCLE</td>
      <td>데이터를 전개하면서 이미 조회한 데이터를 조회하면 CYCLE이 형성되는데, 사이클이 발생되지 않게 함</td>
    </tr>
    <tr>
      <td>Order siblings by 칼럼</td>
      <td>동일한 LEVEL인 형제노드 사이에서 정렬을 수행</td>
    </tr>
  </tbody>
</table>

<h2 id="서브쿼리subquery">서브쿼리(Subquery)</h2>

<hr />

<ul>
  <li>SELECT문 내에 다시 SELECT문을 사용하는 SQL문</li>
  <li>FROM구에 SELECT문을 사용하면 인라인 뷰(Inline View)라고 함</li>
  <li>SELECT문에 서브쿼리를 사용하면 스칼라 서브쿼리(Scala Subquery)라고 함</li>
  <li>WHERE구에 SELECT문을 사용하면 서브쿼리라고 함</li>
  <li>서브쿼리 밖에 있는 SELECT문은 메인쿼리라고 함</li>
  <li>서브쿼리내에서 메인쿼리 내 칼럼을 사용하면 연관 서브쿼리(Correlated Subquery)라고 함</li>
</ul>

<h3 id="단일-행-서브쿼리와-다중-행-서브쿼리">단일 행 서브쿼리와 다중 행 서브쿼리</h3>

<ul>
  <li>단일 행 서브쿼리는 단 하나의 행만 반환하며, 비교 연산자(=, &lt;, ≤, &gt;, ≥, &lt;&gt;)를 사용</li>
  <li>다중 행 서브쿼리는 여러 행을 반환하며, IN, ANY, ALL, EXISTS를 사용</li>
</ul>

<h3 id="다중-행-비교-연산자">다중 행 비교 연산자</h3>

<table>
  <thead>
    <tr>
      <th>연산</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>IN</td>
      <td>메인쿼리의 비교조건이 서브쿼리의 결과 중 하나만 동일하면 참</td>
    </tr>
    <tr>
      <td>ALL</td>
      <td>- 메인쿼리와 서브쿼리의 결과가 모두 동일하면 참<br />- &lt; ALL: 최솟값 반환<br />- &gt; ALL: 최댓값 반환</td>
    </tr>
    <tr>
      <td>ANY</td>
      <td>- 메인쿼리의 비교조건이 서브쿼리의 결과 중 하나 이상 동일하면 참<br />- &lt; ANY: 하나라도 크면 참<br />- &gt; ANY: 하나라도 작으면 참</td>
    </tr>
    <tr>
      <td>EXISTS</td>
      <td>메인쿼리와 서브쿼리의 결과가 하나라도 존재하면 참</td>
    </tr>
  </tbody>
</table>

<h2 id="그룹-함수group-function">그룹 함수(Group Function)</h2>

<hr />

<h3 id="rollup-함수">ROLLUP 함수</h3>

<ul>
  <li>GROUP BY의 칼럼에 대해 Subtotal을 만듦</li>
  <li>ROLLUP을 할 때 GROUP BY구에 칼럼이 두 개 이상 올 시 순서에 따라 결과가 달라짐</li>
</ul>

<h3 id="grouping-함수">GROUPING 함수</h3>

<ul>
  <li>GROUPING 함수는 ROLLUP, CUBE, GROUPING SETS에서 생성되는 합계값을 구분할 수 있음</li>
  <li>GROUPING 함수의 기능을 사용하면 사용자가 필요로 하는 데이터를 SELECT문으로 작성하여 제공할 수 있음</li>
</ul>

<h3 id="grouping-sets-함수">GROUPING SETS 함수</h3>

<ul>
  <li>GROUP BY에 나오는 칼럼의 순서와 관계없이 다양한 소계를 만들 수 있음</li>
  <li>GROUP BY에 나오는 칼럼의 순서와 관계없이 개별적으로 모두 처리</li>
</ul>

<h3 id="cube-함수">CUBE 함수</h3>

<ul>
  <li>제시한 칼럼에 대해 결합 가능한 모든 집계 계산</li>
  <li>다차원 집계를 제공하여 다양하게 데이터를 분석할 수 있음</li>
  <li>조합할 수 있는 경우의 수가 모두 조합되는 것</li>
</ul>

<h2 id="윈도우-함수window-function">윈도우 함수(Window Function)</h2>

<hr />

<ul>
  <li>행과 행 간의 관계를 정의하기 위해 제공되는 함수</li>
  <li>순위, 합계, 평군, 행 위치 등을 조작할 수 있음</li>
</ul>

<h3 id="윈도우-함수-구조">윈도우 함수 구조</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">WINDOW_FUNCTION</span><span class="p">(</span><span class="n">ARGUMENTS</span><span class="p">)</span>
<span class="n">OVER</span> <span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="err">칼럼</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">WINDOWING</span><span class="err">절</span><span class="p">)</span>
<span class="k">FROM</span> <span class="err">테이블</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>구조</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ARGUMENTS(인수)</td>
      <td>윈도우 함수에 따라 0~N개의 인수 설정</td>
    </tr>
    <tr>
      <td>PARTITION BY</td>
      <td>전체 집합을 기준에 의해 소그룹으로 나눔</td>
    </tr>
    <tr>
      <td>ORDER BY</td>
      <td>어떤 항목에 대해 정렬</td>
    </tr>
    <tr>
      <td>WINDOWING</td>
      <td>행 기준의 범위 지정 (추후 설명)</td>
    </tr>
  </tbody>
</table>

<h3 id="windowing">WINDOWING</h3>

<table>
  <thead>
    <tr>
      <th>구조</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ROWS</td>
      <td>부분집합인 윈도우 크기를 물리적 단위로 행의 집합 지정</td>
    </tr>
    <tr>
      <td>RANGE</td>
      <td>논리적인 주소에 의해 행 집합 지정</td>
    </tr>
    <tr>
      <td>BETWEEN~AND</td>
      <td>윈도우의 시작과 끝의 위치를 지정</td>
    </tr>
    <tr>
      <td>UNBOUNDED PRECEDING</td>
      <td>윈도우의 시작 위치가 첫 번째 행임을 의미</td>
    </tr>
    <tr>
      <td>UNBOUNDED FOLLOWING</td>
      <td>윈도우 마지막 위치가 마지막 행임을 의미</td>
    </tr>
    <tr>
      <td>CURRENT ROW</td>
      <td>윈도우 시작 위치가 현재 행임을 의미</td>
    </tr>
  </tbody>
</table>

<h2 id="순위-함수rank-function">순위 함수(RANK Function)</h2>

<hr />

<p>특정 항목과 파티션에 대해 순위를 계산할 수 있는 함수</p>

<h3 id="순위-관련-윈도우-함수">순위 관련 윈도우 함수</h3>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>RANK</td>
      <td>특정 항목 및 파티션에 대해 순위 계산(동일한 순위는 동일한 값 부여)</td>
    </tr>
    <tr>
      <td>DENSE_RANK</td>
      <td>동일한 순위를 하나의 건수로 계산</td>
    </tr>
    <tr>
      <td>ROW_NUMBER</td>
      <td>동일한 순위에 대해 고유의 순위 부여</td>
    </tr>
  </tbody>
</table>

<h2 id="집계-함수aggregate-function">집계 함수(AGGREGATE Function)</h2>

<hr />

<h3 id="집계-관련-윈도우-함수">집계 관련 윈도우 함수</h3>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SUM</td>
      <td>파티션 별로 합계 계산</td>
    </tr>
    <tr>
      <td>AVG</td>
      <td>파티션 별로 평균 계산</td>
    </tr>
    <tr>
      <td>COUNT</td>
      <td>파티션 별로 행 수 계산</td>
    </tr>
    <tr>
      <td>MAX</td>
      <td>파티션 별로 최댓값 계산</td>
    </tr>
    <tr>
      <td>MIN</td>
      <td>파티션 별로 최솟값 계산</td>
    </tr>
  </tbody>
</table>

<h2 id="행-순서-관련-함수">행 순서 관련 함수</h2>

<hr />

<ul>
  <li>상위 행의 값을 하위에 출력하거나 하위 행의 값을 상위 행에 출력 할 수 있음</li>
  <li>특정 위치의 행을 출력할 수 있음</li>
</ul>

<h3 id="행-순서-관련-윈도우-함수">행 순서 관련 윈도우 함수</h3>

<table>
  <thead>
    <tr>
      <th>행 순서</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>FIRST_VALUE</td>
      <td>- 파티션에서 가장 처음에 나오는 값을 구함<br />- MIN 함수를 사용해서 같은 결과를 구할 수 있음</td>
    </tr>
    <tr>
      <td>LAST_VALUE</td>
      <td>- 파티션에서 가장 나중에 나오는 값을 구함<br />- MAX 함수를 사용해서 같은 결과를 구할 수 있음</td>
    </tr>
    <tr>
      <td>LAG</td>
      <td>이전 행을 가져옴</td>
    </tr>
    <tr>
      <td>LEAD</td>
      <td>윈도우에서 특정 위치의 행을 가져옴(기본값: 1)</td>
    </tr>
  </tbody>
</table>

<h2 id="비율-관련-함수">비율 관련 함수</h2>

<hr />

<h3 id="비율-관련-윈도우-함수">비율 관련 윈도우 함수</h3>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CUME_DIST</td>
      <td>파티션 전체 건수에서 현재 행보다 작거나 같은 건수에 대한 누적 백분율 조회(0~1 사이의 값)</td>
    </tr>
    <tr>
      <td>PERCENT_RANK</td>
      <td>파티션에서 제일 먼저 나온 것을 0으로 제일 늦게 나온 것을 1로 하여 값이 아닌 행의 순서별 백분율 조회</td>
    </tr>
    <tr>
      <td>NTILE</td>
      <td>파티션별로 전체 건수를 ARGUMENT 값으로 N등분 한 결과 조회</td>
    </tr>
    <tr>
      <td>RATIO_TO_REPORT</td>
      <td>파티션 내에 전체 SUM(칼럼)에 대한 행 별 칼럼 값의 백분율을 소수점까지 조회</td>
    </tr>
  </tbody>
</table>

<h2 id="테이블-파티션table-partition">테이블 파티션(Table Partition)</h2>

<hr />

<ul>
  <li>파티션은 대용량의 테이블을 여러 개의 데이터 파일에 분리하여 저장하는 기능</li>
  <li>테이블의 데이터가 물리적으로 분리된 데이터 파일에 저장되면 입력, 수정, 삭제, 조회 성능이 향상</li>
  <li>각각의 파티션 별로 독립적으로 괄리될 수 있음(파티션 별로 백업하고 복구가 가능하면 파티션 전용 인덱스 생성도 가능)</li>
  <li>데이터를 조회할 때 데이터의 범위를 줄여 성능 향상</li>
</ul>

<h3 id="파티션-기법">파티션 기법</h3>

<ul>
  <li>Range Partition: 테이블의 칼럼 중 값의 범위를 기준으로 여러 파티션으로 데이터를 나누어 저장하는 방법</li>
  <li>List Partition: 특정 값을 기준으로 분할하는 방법</li>
  <li>Hash Partition: DBMS가 내부적으로 해시 함수를 사용하여 데이터를 분할</li>
  <li>Composite Partition: 여러 개의 파티션 기법을 조합하여 사용하는 방법</li>
</ul>

<h3 id="파티션-인덱스">파티션 인덱스</h3>

<ul>
  <li>Global Index: 여러 개의 파티션에서 하나의 인덱스 사용</li>
  <li>Local Index: 파티션 별로 각자의 인덱스 사용</li>
  <li>Prefixed Index: 파티션 키와 인덱스 키가 동일</li>
  <li>Non Prefixed Index: 파티션 키와 인덱스 키가 다름</li>
</ul>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[[SQL 활용]-Join, Window Function]]></summary></entry><entry><title type="html">DCL(Data Control Language)</title><link href="http://localhost:4000/database/2023/06/08/SQL-%EA%B8%B0%EB%B3%B8-DCL.html" rel="alternate" type="text/html" title="DCL(Data Control Language)" /><published>2023-06-08T06:00:01+09:00</published><updated>2023-06-08T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/08/%5BSQL%20%EA%B8%B0%EB%B3%B8%5DDCL</id><content type="html" xml:base="http://localhost:4000/database/2023/06/08/SQL-%EA%B8%B0%EB%B3%B8-DCL.html"><![CDATA[<h2 id="grant">GRANT</h2>

<hr />

<p>데이터베이스 사용자에게 권한을 부여함</p>

<p><code class="language-plaintext highlighter-rouge">데이터베이스 사용을 위해서는 권한이 필요하며 연결, 입력, 수정, 삭제, 조회를 할 수 있음</code></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">GRANT</span> <span class="err">권한</span> <span class="k">ON</span> <span class="err">테이블</span> <span class="k">TO</span> <span class="err">사용자</span>
</code></pre></div></div>

<h3 id="권한">권한</h3>

<table>
  <thead>
    <tr>
      <th>권한</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SELECT</td>
      <td>지정된 테이블에 대해 SELCET 권한 부여</td>
    </tr>
    <tr>
      <td>INSERT</td>
      <td>지정된 테이블에 대해 INSERT 권한 부여</td>
    </tr>
    <tr>
      <td>UPDATE</td>
      <td>지정된 테이블에 대해 UPDATE 권한 부여</td>
    </tr>
    <tr>
      <td>DELETE</td>
      <td>지정된 테이블에 대해 DELETE 권한 부여</td>
    </tr>
    <tr>
      <td>REFERENCES</td>
      <td>지정된 테이블을 참조하는 제약조건을 생성하는 권한 부여</td>
    </tr>
    <tr>
      <td>ALTER</td>
      <td>지정된 테이블에 대해 ALTER 권한 부여</td>
    </tr>
    <tr>
      <td>INDEX</td>
      <td>지정된 테이블에 대해 인덱스를 생성할 수 있는 권한 부여</td>
    </tr>
    <tr>
      <td>ALL</td>
      <td>지정된 테이블에 대한 모든 권한 부여</td>
    </tr>
  </tbody>
</table>

<h3 id="with-grant-option">WITH GRANT OPTION</h3>

<ul>
  <li>특정 사용자에게 권한을 부여할 수 있는 권한 부여</li>
  <li>권한을 A 사용자가 B에 부여하고 B가 C에게 권한을 부여한 후 권한을 취소하면 모든 권한이 회수됨</li>
</ul>

<h3 id="with-admin-option">WITH ADMIN OPTION</h3>

<ul>
  <li>테이블에 대한 모든 권한 부여</li>
  <li>권한을 A 사용자가 B에 부여하고 B가 C에게 권한을 부여한 후 권한을 취소하면 B 사용자에 대한 권한만 회수됨</li>
</ul>

<h2 id="revoke">REVOKE</h2>

<hr />

<p>데이터베이스 사용자에게 부여된 권한을 회수 함</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">REVOKE</span> <span class="err">권한</span> <span class="k">ON</span> <span class="err">테이블</span> <span class="k">FROM</span> <span class="err">사용자</span>
</code></pre></div></div>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[[SQL 기본]-DCL]]></summary></entry><entry><title type="html">TCL(Transaction Control Language)</title><link href="http://localhost:4000/database/2023/06/08/SQL-%EA%B8%B0%EB%B3%B8-TCL.html" rel="alternate" type="text/html" title="TCL(Transaction Control Language)" /><published>2023-06-08T06:00:01+09:00</published><updated>2023-06-08T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/08/%5BSQL%20%EA%B8%B0%EB%B3%B8%5DTCL</id><content type="html" xml:base="http://localhost:4000/database/2023/06/08/SQL-%EA%B8%B0%EB%B3%B8-TCL.html"><![CDATA[<h2 id="commit">COMMIT</h2>

<hr />

<ul>
  <li>INSERT, UPDATE, DELETE문으로 변경한 데이터를 데이터베이스에 반영</li>
  <li>변경 이전 데이터는 잃어버림</li>
  <li>다른 모든 데이터베이스 사용자는 변경된 데이터를 볼 수 있음</li>
  <li>COMMIT이 완료되면 데이터베이스 변경으로 인한 LOCK이 해제(UNLOCK)됨</li>
  <li>COMMIT이 완료되면 다른 모든 데이터베이스 사용자는 변경된 데이터를 조작할 수 있음</li>
  <li>COMMIT을 실행하면 하나의 트랜잭션 과정을 종료함</li>
</ul>

<h2 id="rollback">ROLLBACK</h2>

<hr />

<ul>
  <li>데이터에 대한 변경 사용을 모두 취소하고 트랜잭션을 종료</li>
  <li>INSERT, UPDATE, DELETE문의 작업을 모두 취소</li>
  <li>이전에 COMMIT한 곳까지만 복구 됨</li>
  <li>ROLLBACK을 실행하면 LOCK이 해제되고 다른 사용자도 데이터베이스를 조작할 수 있음</li>
</ul>

<h2 id="savepoint">SAVEPOINT</h2>

<hr />

<ul>
  <li>트랜잭션을 작게 분할하여 관리하는 것으로 SAVEPOINT를 사용하면 지정된 위치 이후의 트랜잭션만 ROLLBACK할 수 있음</li>
  <li><code class="language-plaintext highlighter-rouge">SAVEPOINT 포인트명</code> 으로 지정할 수 있음</li>
  <li>지정된 SAVEPOINT까지의 데이터 변경을 취소하고 싶을 경우 <code class="language-plaintext highlighter-rouge">ROLLBACK TO 포인트명</code> 을 실행</li>
  <li>ROLLBACK을 실행하면 SAVEPOINT와 관계없이 데이터의 모든 변경사항을 저장하지 않음</li>
</ul>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[[SQL 기본]-TCL]]></summary></entry><entry><title type="html">DML(Data Manipulation Language)</title><link href="http://localhost:4000/database/2023/06/07/SQL-%EA%B8%B0%EB%B3%B8-DML.html" rel="alternate" type="text/html" title="DML(Data Manipulation Language)" /><published>2023-06-07T06:00:01+09:00</published><updated>2023-06-07T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/07/%5BSQL%20%EA%B8%B0%EB%B3%B8%5DDML</id><content type="html" xml:base="http://localhost:4000/database/2023/06/07/SQL-%EA%B8%B0%EB%B3%B8-DML.html"><![CDATA[<h2 id="insert">INSERT</h2>

<hr />

<p>테이블에 데이터를 입력하는 DML문</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="err">테이블</span><span class="p">(</span><span class="err">칼럼</span><span class="mi">1</span><span class="p">,</span> <span class="err">칼럼</span><span class="mi">2</span><span class="p">,</span> <span class="p">...)</span> <span class="k">VALUES</span><span class="p">(</span><span class="err">값</span><span class="mi">1</span><span class="p">,</span> <span class="err">값</span><span class="mi">2</span><span class="p">,</span> <span class="p">...)</span>
</code></pre></div></div>

<p>칼럼명은 생략이 가능하다 (칼럼의 순서를 맞춰야함)</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="err">테이블</span> <span class="k">VALUES</span><span class="p">(</span><span class="err">값</span><span class="mi">1</span><span class="p">,</span> <span class="err">값</span><span class="mi">2</span><span class="p">,</span> <span class="p">...)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">문자열을 입력하는 경우 작은따옴표(' ')를 사용해야 한다</code></p>

<p>INSERT문을 실행했다고 데이터 파일에 저장되는 것은 아님. 최종적으로 TCL문인 <code class="language-plaintext highlighter-rouge">Commit</code>을 실행해야 함</p>

<h2 id="update">UPDATE</h2>

<hr />

<p>입력된 데이터의 값을 수정할 수 있음</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="err">테이블</span> <span class="k">SET</span> <span class="err">칼럼</span><span class="o">=</span><span class="err">값</span> <span class="k">WHERE</span> <span class="err">조건</span>
</code></pre></div></div>

<p>위의 쿼리는 조건에 맞는 ROW의 칼럽을 수정하는 쿼리이다</p>

<h2 id="delete">DELETE</h2>

<hr />

<p>원하는 조건을 검색하여 해당 ROW를 삭제할 수 있음</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DELETE</span> <span class="k">FROM</span> <span class="err">테이블</span> <span class="k">WHERE</span> <span class="err">조건</span>
</code></pre></div></div>

<h3 id="테이블의-모든-데이터-삭제">테이블의 모든 데이터 삭제</h3>

<table>
  <thead>
    <tr>
      <th>DELETE FROM 테이블</th>
      <th>TRUNCATE TABLE 테이블</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>테이블의 모든 데이터를 삭제</td>
      <td>테이블의 모든 데이터 삭제</td>
    </tr>
    <tr>
      <td>데이터가 삭제되어도 테이블의 용량 감소 X</td>
      <td>데이터가 삭제되면 테이블의 용량은 초기화</td>
    </tr>
  </tbody>
</table>

<h2 id="select">SELECT</h2>

<hr />

<p>테이블에 입력된 데이터 조회</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="err">테이블</span>
</code></pre></div></div>

<p>위의 쿼리는 해당 테이블의 모든 데이터를 조회한다</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="err">테이블</span> <span class="k">WHERE</span> <span class="err">조건</span>
</code></pre></div></div>

<p>위의 쿼리는 해당 테이블에서 조건이 맞는 모든 데이터를 조회한다</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="err">칼럼</span><span class="mi">1</span><span class="p">,</span> <span class="err">칼럼</span><span class="mi">2</span> <span class="k">FROM</span> <span class="err">테이블</span>
</code></pre></div></div>

<p>위의 쿼리는 해당 테이블에서 모든 데이터의 칼럼1과 2만 조회한다</p>

<p><code class="language-plaintext highlighter-rouge">DISTINCT는 칼럼명 앞에 지정하며 중복된 데이터를 한 번만 조회함</code></p>

<h2 id="where">WHERE</h2>

<hr />

<p>WHERE문은 비교 연산자, 부정 비교 연산자, 논리 연산자, SQL 연산자, 부정 SQL 연산자를 사용할 수 있다</p>

<h3 id="비교-연산자">비교 연산자</h3>

<table>
  <thead>
    <tr>
      <th>비교 연산자</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>=</td>
      <td>같은 것을 조회</td>
    </tr>
    <tr>
      <td>&lt;</td>
      <td>작은 것을 조회</td>
    </tr>
    <tr>
      <td>&lt;=</td>
      <td>작거나 같은 것을 조회</td>
    </tr>
    <tr>
      <td>&gt;</td>
      <td>큰 것을 조회</td>
    </tr>
    <tr>
      <td>&gt;=</td>
      <td>크거나 같은 것을 조회</td>
    </tr>
  </tbody>
</table>

<h3 id="부정-비교-연산자">부정 비교 연산자</h3>

<table>
  <thead>
    <tr>
      <th>부정 비교 연산자</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>!=</td>
      <td>같지 않은 것을 조회</td>
    </tr>
    <tr>
      <td>^=</td>
      <td>같지 않은 것을 조회</td>
    </tr>
    <tr>
      <td>&lt;&gt;</td>
      <td>같지 않은 것을 조회</td>
    </tr>
    <tr>
      <td>NOT 칼럼명 =</td>
      <td>같지 않은 것을 조회</td>
    </tr>
    <tr>
      <td>NOT 칼럼명 &gt;</td>
      <td>크지 않은 것을 조회</td>
    </tr>
  </tbody>
</table>

<h3 id="논리-연산자">논리 연산자</h3>

<table>
  <thead>
    <tr>
      <th>논리 연산자</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>AND</td>
      <td>조건을 모두 만족해야 참(True)</td>
    </tr>
    <tr>
      <td>OR</td>
      <td>조건 중 하나만 만족해도 참(True)</td>
    </tr>
    <tr>
      <td>NOT</td>
      <td>참이면 거짓(False)으로 바꾸고 거짓이면 참(True)로 바꿈</td>
    </tr>
  </tbody>
</table>

<h3 id="sql-연산자">SQL 연산자</h3>

<table>
  <thead>
    <tr>
      <th>SQL 연산자</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>LIKE ‘%비교 문자열%’</td>
      <td>비교 문자열 조회 (%는 모든 값을 의미하는 와일드 카드)</td>
    </tr>
    <tr>
      <td>BETWEEN A AND B</td>
      <td>A와 B 사이의 값 조회</td>
    </tr>
    <tr>
      <td>IN (list)</td>
      <td>OR을 의미하며 list 값 중 하나만 일치해도 조회</td>
    </tr>
    <tr>
      <td>IS NULL</td>
      <td>NULL 값 조회</td>
    </tr>
  </tbody>
</table>

<h3 id="부정-sql-연산자">부정 SQL 연산자</h3>

<table>
  <thead>
    <tr>
      <th>부정 SQL 연산자</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NOT BETWEEN A AND B</td>
      <td>A와 B 사이의 해당되지 않는 값 조회</td>
    </tr>
    <tr>
      <td>NOT IN (list)</td>
      <td>list와 불일치한 것 조회</td>
    </tr>
    <tr>
      <td>IS NOT NULL</td>
      <td>NULL 값이 아닌 것 조회</td>
    </tr>
  </tbody>
</table>

<h3 id="와일드-카드">와일드 카드</h3>

<table>
  <thead>
    <tr>
      <th>와일드 카드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>%</td>
      <td>어떤 문자를 포함한 모든 것 조회</td>
    </tr>
    <tr>
      <td>_</td>
      <td>한 개인 단일 문자</td>
    </tr>
  </tbody>
</table>

<h3 id="null-관련-함수">NULL 관련 함수</h3>

<table>
  <thead>
    <tr>
      <th>NULL 함수</th>
      <th>DBMS</th>
      <th>사용법</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NVL</td>
      <td>Oracle</td>
      <td>NVL(칼럼, 값)</td>
      <td>칼럼이 NULL이면 다른 값으로 바꾸는 함수<br />예에서 칼럼이 NULL이면 값 반환</td>
    </tr>
    <tr>
      <td>NVL2</td>
      <td>Oracle</td>
      <td>NVL2(칼럼, 값1, 값2)</td>
      <td>칼럼이 NULL이 아니면 값1, NULL이면 값2 반환</td>
    </tr>
    <tr>
      <td>NULLIF</td>
      <td>Oracle, MS-SQL, MySQL</td>
      <td>NULLIF(값1, 값2)</td>
      <td>두개의 값이 같으면 NULL을, 같지 않으면 첫 번째 값 반환</td>
    </tr>
    <tr>
      <td>COALESCE</td>
      <td>Oracle, MS-SQL</td>
      <td>COALESCE(값1, 값2, … )</td>
      <td>NULL이 아닌 최초의 값 반환</td>
    </tr>
  </tbody>
</table>

<h2 id="group-연산">GROUP 연산</h2>

<hr />

<h3 id="group-by">GROUP BY</h3>

<ul>
  <li>테이블에서 소규모 행을 그룹화하여 합계, 평균, 최댓값, 최솟값 등을 계산할 수 있음</li>
  <li>HAVING 절에 조건문을 사용</li>
  <li>Grouping된 결과에 대한 조건문 사용</li>
  <li>ORDER BY를 사용하여 정렬 가능</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">DEPTNO</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">SAL</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">EMP</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">DEPTNO</span>
</code></pre></div></div>

<p>위의 쿼리는 DEPTNO로 그룹을 만들어 <code class="language-plaintext highlighter-rouge">SUM(SAL)</code> 을 이용해 그룹별 합계를 계산함</p>

<h3 id="having">HAVING</h3>

<p>GROUP BY에 조건을 사용하기 위해선 HAVING을 사용해야 함</p>

<p>만약 WHERE절에 조건문을 사용하면 조건을 충족하지 못하는 데이터들은 GROUP BY 대상에서 제외</p>

<h3 id="집계함수">집계함수</h3>

<table>
  <thead>
    <tr>
      <th>집계함수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>COUNT()</td>
      <td>행 수 계산</td>
    </tr>
    <tr>
      <td>SUM()</td>
      <td>합계 계산</td>
    </tr>
    <tr>
      <td>AVG()</td>
      <td>평균 계산</td>
    </tr>
    <tr>
      <td>MAX()</td>
      <td>최댓값 계산</td>
    </tr>
    <tr>
      <td>MIN()</td>
      <td>최솟값 계산</td>
    </tr>
    <tr>
      <td>STDDEV()</td>
      <td>표준편차 계산</td>
    </tr>
    <tr>
      <td>VARIANCE()</td>
      <td>분산 계산</td>
    </tr>
  </tbody>
</table>

<h3 id="데이터-조회-실행-순서">데이터 조회 실행 순서</h3>

<ol>
  <li>SELECT</li>
  <li>FROM</li>
  <li>WHERE</li>
  <li>GROUP BY</li>
  <li>HAVING</li>
  <li>ORDER BY</li>
</ol>

<h2 id="형변환">형변환</h2>

<hr />

<p>두 개의 데이터의 데이터 타입이 일치하도록 변환하는 것</p>

<p>명시적(Explicit) 형변환과 암시적(Implicit) 형변환이 있음</p>

<h3 id="형변환-함수">형변환 함수</h3>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TO_NUMBER(문자열)</td>
      <td>문자열을 숫자로 변환</td>
    </tr>
    <tr>
      <td>TO_CHAR(숫자 혹은 날짜, FORMAT)</td>
      <td>숫자 혹은 날짜를 지정된 FORMAT의 문자로 변환</td>
    </tr>
    <tr>
      <td>TO_DATE(문자열, FORMAT)</td>
      <td>문자열을 지정된 FORMAT의 날짜형으로 변환</td>
    </tr>
  </tbody>
</table>

<h2 id="내장형-함수">내장형 함수</h2>

<hr />

<h3 id="dual-테이블">DUAL 테이블</h3>

<p>Oracle 데이터베이스에 의해 자동으로 생성되는 테이블</p>

<h3 id="문자열-함수">문자열 함수</h3>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>DBMS</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ASCII(문자)</td>
      <td> </td>
      <td>문자 혹은 숫자를 ASCII 코드값으로 변환</td>
    </tr>
    <tr>
      <td>CHR(ASCII코드)</td>
      <td>Oracle</td>
      <td>ASCII 코드값을 문자로 변환</td>
    </tr>
    <tr>
      <td>CHAR(ASCII코드)</td>
      <td>MS-SQL, MySQL</td>
      <td>ASCII 코드값을 문자로 변환</td>
    </tr>
    <tr>
      <td>SUBSTR(문자열, m, n)</td>
      <td> </td>
      <td>문자열에서 m번째 위치부터 n개 자름</td>
    </tr>
    <tr>
      <td>CONCAT(문자열1, 문자열2)</td>
      <td> </td>
      <td>문자열1과 문자열2를 결합한다</td>
    </tr>
    <tr>
      <td>LOWER(문자열)</td>
      <td> </td>
      <td>영문자를 소문자로 변환</td>
    </tr>
    <tr>
      <td>UPPER(문자열)</td>
      <td> </td>
      <td>영문자를 대문자로 변환</td>
    </tr>
    <tr>
      <td>LENGTH</td>
      <td> </td>
      <td>공백을 포함한 문자열의 길이 반환</td>
    </tr>
    <tr>
      <td>LEN(문자열)</td>
      <td> </td>
      <td>공백을 포함한 문자열의 길이 반환</td>
    </tr>
    <tr>
      <td>LTRIM(문자열, 지정문자)</td>
      <td> </td>
      <td>왼쪽에서 지정된 문자를 삭제 (지정 문자를 생략시 공백 제거)</td>
    </tr>
    <tr>
      <td>RTRIM(문자열, 지정문자)</td>
      <td> </td>
      <td>오른쪽에서 지정된 문자를 삭제 (지정 문자를 생략시 공백 제거)</td>
    </tr>
    <tr>
      <td>TRIM(문자열, 지정문자)</td>
      <td> </td>
      <td>왼쪽 및 오른쪽에서 지정된 문자를 삭제 (지정 문자를 생략시 공백 제거)</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">DBMS의 공백은 모든 DBMS가 지원하는 함수</code></p>

<h3 id="날짜형-함수">날짜형 함수</h3>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SYSDATE</td>
      <td>현재 날짜를 날짜 타입으로 반환</td>
    </tr>
    <tr>
      <td>EXTRACT(’YEAR’ | ‘MONTH’ | ‘DAY’ from dual)</td>
      <td>날짜에서 년, 월, 일을 조회</td>
    </tr>
  </tbody>
</table>

<h3 id="숫자형-함수">숫자형 함수</h3>

<table>
  <thead>
    <tr>
      <th>함수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ABS(숫자)</td>
      <td>절댓값 반환</td>
    </tr>
    <tr>
      <td>SIGN(숫자)</td>
      <td>양수, 음수, 0을 구별</td>
    </tr>
    <tr>
      <td>MOD(숫자1, 숫자2)</td>
      <td>숫자1을 숫자2로 나누어 나머지 계산(%를 사용해도 됨)</td>
    </tr>
    <tr>
      <td>CEIL(숫자)</td>
      <td>숫자보다 크거나 같은 최소의 정수 반환</td>
    </tr>
    <tr>
      <td>CEILING(숫자)</td>
      <td>숫자보다 크거나 같은 최소의 정수 반환</td>
    </tr>
    <tr>
      <td>FLOOR(숫자)</td>
      <td>숫자보다 작거나 같은 최대의 정수 반환</td>
    </tr>
    <tr>
      <td>ROUND(숫자, m)</td>
      <td>소수점 m 자리에서 반올림 (m 생략 시 0 지정)</td>
    </tr>
    <tr>
      <td>TRUNC(숫자, m)</td>
      <td>소수점 m 자리에서 절삭 (m 생략 시 0 지정)</td>
    </tr>
  </tbody>
</table>

<h2 id="decode">DECODE</h2>

<hr />

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DECODE</span><span class="p">(</span><span class="err">칼럼</span><span class="p">,</span> <span class="err">값</span><span class="p">,</span> <span class="err">값</span><span class="mi">1</span><span class="p">,</span> <span class="err">값</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>칼럼과 값이 같으면(참) 값1을, 같지 않으면(거짓) 값2를 반환</p>

<h2 id="case">CASE</h2>

<hr />

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">CASE</span>
	<span class="k">WHEN</span> <span class="err">조건</span><span class="mi">1</span> <span class="k">THEN</span> <span class="err">값</span><span class="mi">1</span>
	<span class="k">WHEN</span> <span class="err">조건</span><span class="mi">2</span> <span class="k">THEN</span> <span class="err">값</span><span class="mi">2</span>
	<span class="k">ELSE</span> <span class="err">값</span><span class="mi">3</span>
	<span class="k">END</span>
<span class="k">FROM</span> <span class="err">테이블</span>
</code></pre></div></div>

<p>위의 쿼리는 테이블에서 맞는 조건에 따른 값 반환과 조건이 맞지 않을 시 값3을 출력한다</p>

<h2 id="rownum">ROWNUM</h2>

<hr />

<ul>
  <li>Oracle 데이터베이스의 SELECT문 결과에 대해 논리적인 일련번호를 부여함</li>
  <li>조회되는 행 수를 제한할 때 많이 사용됨</li>
  <li>화면에 데이터를 출력할 때 부여되는 논리적 순번</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">인라인 뷰(Inline view): SELCET문에서 FROM 절에 사용되는 서브쿼리(Sub Query)를 의미</code></p>

<h2 id="rowid">ROWID</h2>

<hr />

<ul>
  <li>Oracle 데이터베이스 내에서 데이터를 구불할 수 있는 유일한 값</li>
  <li>“SELECT ROWID, 갈럼 FROM 테이블” 처럼 SELECT문으로 확인할 수 있음</li>
  <li>데이터가 어떤 데이터 파일, 어느 블록에 저장되어 있는지 알 수 있음</li>
</ul>

<h3 id="rowid-구조">ROWID 구조</h3>

<table>
  <thead>
    <tr>
      <th>구조</th>
      <th>길이</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>오브젝트 번호</td>
      <td>1~6</td>
      <td>오브젝트 별로 유일한 값을 가지고 있으며, 해당 오브젝트가 속한 값</td>
    </tr>
    <tr>
      <td>상대 파일 번호</td>
      <td>7~9</td>
      <td>테이블스페이스에 속해 있는 데이터 파일에 대한 상대 파일 번호</td>
    </tr>
    <tr>
      <td>블록 번호</td>
      <td>10~15</td>
      <td>데이터 파일 내부에서 어느 블록에 데이터가 있는지 알려줌</td>
    </tr>
    <tr>
      <td>데이터 번호</td>
      <td>16~18</td>
      <td>데이터 블록에 데이터가 저장되어 있는 순서</td>
    </tr>
  </tbody>
</table>

<h2 id="with">WITH</h2>

<hr />

<ul>
  <li>서브쿼리(Subquery)를 사용하여 임시 테이블이나 뷰처럼 사용할 수 있는 구문</li>
  <li>서브쿼리 블록에 별칭을 지정할 수 있음</li>
  <li>옵티마이저는 SQL을 인라인 뷰나 임시 테이블로 판단</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WITH</span> <span class="err">임시테이블명</span> <span class="k">AS</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="err">테이블</span>
<span class="k">UNION</span> <span class="k">ALL</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="err">테이블</span><span class="p">)</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="err">임시테이블명</span> <span class="k">WHERE</span> <span class="err">조건</span>
</code></pre></div></div>

<p>위의 쿼리는 WITH구문의 예</p>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[[SQL 기본]-DML]]></summary></entry><entry><title type="html">DDL(Data Definition Language)</title><link href="http://localhost:4000/database/2023/06/06/SQL-%EA%B8%B0%EB%B3%B8-DDL.html" rel="alternate" type="text/html" title="DDL(Data Definition Language)" /><published>2023-06-06T06:00:01+09:00</published><updated>2023-06-06T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/06/%5BSQL%20%EA%B8%B0%EB%B3%B8%5DDDL</id><content type="html" xml:base="http://localhost:4000/database/2023/06/06/SQL-%EA%B8%B0%EB%B3%B8-DDL.html"><![CDATA[<h2 id="sql-기본">SQL 기본</h2>

<hr />

<h3 id="sql의-종류">SQL의 종류</h3>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
      <th>구문</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>DDL(Data Definition Language)</td>
      <td>관계형 데이터베이스의 구조를 정의하는 언어</td>
      <td>CREATE, ALTER, DROP, RENAME, TRUNCATE</td>
    </tr>
    <tr>
      <td>DML(Data Manipulation Language)</td>
      <td>테이블에서 데이터를 입력, 수정, 삭제, 조회</td>
      <td>INSERT, UPDATE, DELETE, SELECT</td>
    </tr>
    <tr>
      <td>DCL(Data Control Language)</td>
      <td>데이터베이스 사용자에게 권한을 부여하거나 회수</td>
      <td>GRANT, REVOKE</td>
    </tr>
    <tr>
      <td>TCL(Transaction Control Language)</td>
      <td>트랜잭션을 제어하는 명령어</td>
      <td>COMMIT, ROLLBACK, SAVEPOINT</td>
    </tr>
  </tbody>
</table>

<h3 id="트랜잭션">트랜잭션</h3>

<p>데이터베이스의 작업을 처리하는 단위</p>

<h3 id="특징">특징</h3>

<table>
  <thead>
    <tr>
      <th>특징</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>원자성(Atomicity)</td>
      <td>- 트랜잭션은 데이터베이스 연산의 전부가 실행되거나 전혀 실행되지 않아야 함<br />- 트랜잭션의 처리가 완전히 끝나지 않았을 경우는 실행되지 않은 상태와 같아야 함</td>
    </tr>
    <tr>
      <td>일관성(Consistency)</td>
      <td>- 트랜잭션 실행 결과로 데이터베이스의 상태가 모순되지 않아야 함<br />- 트랜잭션 실행 후에도 일관성이 유지되어야 함</td>
    </tr>
    <tr>
      <td>고립성(Isolation)</td>
      <td>- 트랜잭션 실행 중에 생성하는 연산의 중간결과는 다른 트랜잭션이 접근할 수 없음<br />- 부분적인 실행 결과를 다른 트랜잭션이 볼 수 없음</td>
    </tr>
    <tr>
      <td>영속성(Durability)</td>
      <td>트랜잭션이 실행을 성공적으로 완료하면 그 결과는 영구적 보장</td>
    </tr>
  </tbody>
</table>

<h3 id="sql-실행-순서">SQL 실행 순서</h3>

<ul>
  <li>파싱(Parsing): SQL문의 문법을 확인하고 구문을 분석함(구문 분석한 SQL문은 Library Cache에 저장)</li>
  <li>실행(Execution): 옵티마이저가 수립한 실행 계획에 따라 SQL 실행</li>
  <li>인출(Fetch): 데이터를 읽어서 전송</li>
</ul>

<h2 id="테이블-생성">테이블 생성</h2>

<hr />

<h3 id="기본적인-테이블-생성">기본적인 테이블 생성</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Create</span> <span class="k">Table</span> <span class="n">EMP</span>
<span class="p">(</span>
  <span class="n">empno</span> <span class="n">number</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>   <span class="o">//</span> <span class="n">empno</span><span class="err">은</span> <span class="err">최대</span> <span class="mi">10</span><span class="err">자리</span> <span class="err">숫자로</span> <span class="err">기본키이다</span>
  <span class="n">ename</span> <span class="n">varchar2</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>    <span class="o">//</span> <span class="n">ename</span><span class="err">은</span> <span class="err">최대</span> <span class="mi">20</span><span class="err">자리의</span> <span class="err">가변</span> <span class="err">길이</span> <span class="err">문자로</span> <span class="err">공백</span> <span class="err">허용</span><span class="n">X</span>
  <span class="n">sal</span> <span class="n">number</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>                  <span class="o">//</span> <span class="n">sal</span><span class="err">은</span> <span class="err">최대</span> <span class="mi">6</span><span class="err">자리</span> <span class="err">숫자</span>
  <span class="n">createdate</span> <span class="nb">date</span> <span class="k">default</span> <span class="n">sysdate</span> <span class="o">//</span> <span class="n">createdate</span><span class="err">는</span> <span class="err">날짜를</span> <span class="err">입력받으며</span> <span class="err">기본값으로</span> <span class="err">현재</span> <span class="err">날짜</span>
<span class="p">)</span>
</code></pre></div></div>

<h2 id="제약조건">제약조건</h2>

<hr />

<p><code class="language-plaintext highlighter-rouge">제약조건은 기본키, 외래키, 기본값, not null을 테이블을 생성할 때 지정할 수 있음</code></p>

<h3 id="기본키-지정">기본키 지정</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constraint</span> <span class="err">키이름</span> <span class="k">primary</span> <span class="k">key</span><span class="p">(</span><span class="err">키이름</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="외래키-지정">외래키 지정</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constraint</span> <span class="err">외래키</span> <span class="k">foreign</span> <span class="k">key</span><span class="p">(</span><span class="err">키이름</span><span class="p">)</span> <span class="k">references</span> <span class="err">테이블</span><span class="p">(</span><span class="err">키이름</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="cascade">CASCADE</h3>

<p>CASCADE 옵션은 참조 관계가 있을 경우 참조되는 데이터를 자동으로 반영할 수 있음</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constraint</span> <span class="err">외래키</span> <span class="k">foreign</span> <span class="k">key</span><span class="p">(</span><span class="err">키이름</span><span class="p">)</span> <span class="k">references</span> <span class="err">테이블</span><span class="p">(</span><span class="err">키이름</span><span class="p">)</span> <span class="k">ON</span> <span class="k">DELETE</span> <span class="k">CASCADE</span>
</code></pre></div></div>

<p>위의 쿼리문은 자신이 참조하는 테이블의 데이터가 삭제되면 자동으로 자신도 삭제되는 옵션</p>

<h2 id="테이블-수정">테이블 수정</h2>

<hr />

<p>ALTER TABLE문을 통해 테이블명 변경, 칼럼 추가, 변경, 삭제 등을 할 수 있다.</p>

<h3 id="테이블명-변경">테이블명 변경</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">기존테이블명</span> <span class="k">TO</span> <span class="err">새로운테이블명</span>
</code></pre></div></div>

<h3 id="칼럼-추가">칼럼 추가</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">테이블명</span> <span class="k">ADD</span><span class="p">(</span><span class="err">칼럼명</span> <span class="err">자료형</span> <span class="err">조건</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="칼럼-변경">칼럼 변경</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">테이블명</span> <span class="k">MODIFY</span><span class="p">(</span><span class="err">칼럼명</span> <span class="err">자료형</span> <span class="err">조건</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="칼럼-삭제">칼럼 삭제</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">테이블명</span> <span class="k">DROP</span> <span class="k">COLUMN</span> <span class="err">칼럼명</span>
</code></pre></div></div>

<h3 id="칼럼명-변경">칼럼명 변경</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="err">테이블명</span> <span class="k">RENAME</span> <span class="k">COLUMN</span> <span class="err">칼럼명</span> <span class="k">to</span> <span class="err">새로운칼럼명</span>
</code></pre></div></div>

<h2 id="테이블-삭제">테이블 삭제</h2>

<hr />

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DROP</span> <span class="k">TABLE</span> <span class="err">테이블명</span>
</code></pre></div></div>

<h2 id="뷰view-생성과-삭제">뷰(VIEW) 생성과 삭제</h2>

<hr />

<ul>
  <li>뷰는 테이블로부터 유도된 가상의 테이블</li>
  <li>실제 데이터를 가지고 있지 않고테이블을 참조해 원하는 칼럼만을 조죄할 수 있음</li>
  <li>뷰는 데이터 딕셔너리(Data Dictionary)에 SQL문 형태로 저장하되 실행 시 참조됨</li>
</ul>

<h3 id="뷰의-특징">뷰의 특징</h3>

<ul>
  <li>참조한 테이블이 변경되면 뷰도 변경됨</li>
  <li>뷰의 검색은 참조한 테이블과 동일하게 할 수 있지만, 뷰에 대한 입력, 수정, 삭제에는 제약이 있음</li>
  <li>특정 칼럼만 조회시켜 보안성을 향상시킴</li>
  <li>한번 생성된 뷰는 변경할 수  없고 변경을 원하면 삭제 후 재생성해야 함</li>
  <li>ALTER문을 사용하여 뷰를 변경할 수 없음</li>
</ul>

<h3 id="생성">생성</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">VIEW</span> <span class="err">뷰이름</span> <span class="k">AS</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="err">테이블</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">뷰의 조회는 SELECT문을 사용하여 일반 테이블처럼 조회함</code></p>

<h3 id="삭제">삭제</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">DROP</span> <span class="k">VIEW</span> <span class="err">뷰이름</span>
</code></pre></div></div>

<h3 id="장점">장점</h3>

<ul>
  <li>특정 칼럼만 조회할 수 있기에 보안 기능이 있음</li>
  <li>데이터 관리가 간단</li>
  <li>SELECT문이 간단해짐</li>
  <li>하나의 테이블에 여러 뷰를 생성할 수 있음</li>
</ul>

<h3 id="단점">단점</h3>

<ul>
  <li>뷰는 독자적인 인덱스를 만들 수 없음</li>
  <li>삽입, 수정, 삭제 연산이 제약됨</li>
  <li>데이터 구조를 변경할 수 없음</li>
</ul>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[[SQL 기본]-DDL]]></summary></entry><entry><title type="html">정규화</title><link href="http://localhost:4000/database/2023/06/05/%EC%A0%95%EA%B7%9C%ED%99%94.html" rel="alternate" type="text/html" title="정규화" /><published>2023-06-05T06:00:01+09:00</published><updated>2023-06-05T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/05/%EC%A0%95%EA%B7%9C%ED%99%94</id><content type="html" xml:base="http://localhost:4000/database/2023/06/05/%EC%A0%95%EA%B7%9C%ED%99%94.html"><![CDATA[<h2 id="정규화normalization">정규화(Normalization)</h2>

<hr />

<ul>
  <li>데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이며 데이터를 분해하는 과정</li>
  <li>중복을 제거하고 데이터 모델의 독립성을 확보하기 위한 방법</li>
  <li>테이블을 분해해서 데이터 중복을 제거하기 때문에 데이터 모델의 유연성을 높임</li>
  <li>정규화 수행시 비즈니스에 변화가 발생하여도 데이터 모델의 변경을 최소화할 수 있음</li>
  <li>제1정규화부터 제5정규화까지 있지만, 실질적으로 제3정규화까지만 수행</li>
</ul>

<h3 id="정규화-절차">정규화 절차</h3>

<table>
  <thead>
    <tr>
      <th>정규화 절차</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>제1정규화</td>
      <td>- 속성의 원자성 확보<br />- 기본키 설정</td>
    </tr>
    <tr>
      <td>제2정규화</td>
      <td>- 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거(분해)<br />- 기본키가 하나의 칼럼으로 이루어지면 제2정규화는 생략</td>
    </tr>
    <tr>
      <td>제3정규화</td>
      <td>- 기본키를 제외한 칼럼 간에 종속성을 제거<br />- 이행 함수 종속성을 제거</td>
    </tr>
    <tr>
      <td>BCNF</td>
      <td>기본키를 제외하고 후보키가 있는 경우, 후보키가 기본키를 종속시키면 분해</td>
    </tr>
    <tr>
      <td>제4정규화</td>
      <td>여러 칼럼들이 하나의 칼럼을 종속시키는 경우 분해하여 다중값 종속성 제거</td>
    </tr>
    <tr>
      <td>제5정규화</td>
      <td>조인에 의해 종속성이 발생되는 경우 분해</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">정규화의 문제점: 정규화는 데이터 조회(SELECT) 시에 조인(Join)을 유발하기에 CPU와 메모리를 많이 사용.</code></p>

<h2 id="반정규화de-normalization">반정규화(De-Normalization)</h2>

<hr />

<p>데이터베이스의 성능 향상을 위해 데티어 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법</p>

<p>조회(SELECT) 속도를 향상하지만, 데이터 모델의 유연성은 낮아짐</p>

<h3 id="반정규화를-수행하는-경우">반정규화를 수행하는 경우</h3>

<ul>
  <li>정규화에 충실하면 종속성, 활용성은 향상되지만 숙도가 느려지는 경우</li>
  <li>다량의 범위를 자주 처리해야 하는 경우</li>
  <li>특정 범위의 데이터만 자주 처리하는 경우</li>
  <li>요약/집계 정보가 자주 요구되는 경우</li>
</ul>

<h3 id="반정규화-절차">반정규화 절차</h3>

<ul>
  <li>대상 조사 및 검토: 데이터 처리 범위, 통계성 등을 확인해서 반정규화 대상 조사</li>
  <li>다른 방법 검토: 반정규화를 수행하기 전에 다른 방법이 있는지 검토(클러스터링, 뷰, 인덱스 튜닝, 응용프로그램, 파티션 검토)</li>
  <li>반정규화 수행: 테이블, 속성, 관계 등을 반정규화</li>
</ul>

<h3 id="반정규화-기법">반정규화 기법</h3>

<ul>
  <li>계산된 칼럼 추가</li>
  <li>테이블 수직 분할: 하나의 테이블을 두 개 이상의 테이블로 분할 (칼럼을 분할하여 새로운 테이블 생성)</li>
  <li>테이블 수평 분할: 하나의 테이블에 있는 값을 기준으로 테이블 분할</li>
  <li>테이블 병합: 테이블을 하나의 테이블로 병합하여 성능 향상</li>
</ul>

<h3 id="파티션partition-기법">파티션(Partition) 기법</h3>

<p>데이터베이스에서 파티션을 사용하여 테이블을 분할할 수 있음.</p>

<p>파티션을 사용하면 논리적으로는 하나의 테이블이지만 여러 개의 데이터 파일에 분산되어 저장됨.</p>

<table>
  <thead>
    <tr>
      <th>기법</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Range Partition</td>
      <td>데이터 값의 범위를 기준으로 파티션 수행</td>
    </tr>
    <tr>
      <td>List Partition</td>
      <td>특정한 값을 지정하여 파티션 수행</td>
    </tr>
    <tr>
      <td>Hash Partition</td>
      <td>해시 함수를 적용하여 파티션 수행</td>
    </tr>
    <tr>
      <td>Composite Partition</td>
      <td>범위와 해시를 복합적으로 사용하여 파티션 수행</td>
    </tr>
  </tbody>
</table>

<p>파티션 테이블의 장점</p>

<ul>
  <li>데이터 조회 시 액세스 범위가 줄어들기에 성능 향상</li>
  <li>데이터가 분할되어 있기에 I/O(Input/Output)의 성능 향상</li>
  <li>각 파티션을 독립적으로 백업 및 복구 가능</li>
</ul>

<h3 id="테이블-병합">테이블 병합</h3>

<ul>
  <li>1대1 관계의 테이블을 하나의 테이블로 병합하여 성능 향상</li>
  <li>1대N 관계의 테이블을 병합하여 성능 향상, 많은 양의 데이터 중복이 발생</li>
  <li>슈퍼 타입과 서브 타입 관계가 발생하면 테이블을 통합하여 성능 향상</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Super Type, Sub Type: 엔터티에 중복되는 값을 상속 Super Type은 부모, Sub Type은 자식으로 생각하면 됨</code></p>

<h3 id="슈퍼-타입-및-서브-타입-변환-방법">슈퍼 타입 및 서브 타입 변환 방법</h3>

<table>
  <thead>
    <tr>
      <th>변환 방법</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>OneToOne Type</td>
      <td>- 슈퍼 타입과 서브 타입을 개별 테이블로 도출<br />- 테이블의 수가 많아서 조인이 많이 발생하고 관리가 어려움</td>
    </tr>
    <tr>
      <td>Plus Type</td>
      <td>- 슈퍼 타입과 서브 타입 테이블로 도출<br />- 조인이 발생하고 관리가 어려움</td>
    </tr>
    <tr>
      <td>Single Type</td>
      <td>- 슈퍼 타입과 서브 타입을 하나의 테이블로 도출<br />- 조인 성능이 좋고 관리가 편하지만, 입출력 성능이 나쁨</td>
    </tr>
  </tbody>
</table>

<h2 id="분산-데이터베이스">분산 데이터베이스</h2>

<hr />

<ul>
  <li>중앙 집중형 데이터베이스: 한 대의 물리적 시스템에 DBMS를 설치하고 여러 명의 사용자가 DBMS에 접속하여 데이터베이스를 사용하는 구조</li>
  <li>분산 데이터베이스: 물리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스 이미지를 보여 주고 분산된 작업 처리를 수행하는 데이터베이스</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">DBMS: 데이터베이스 관리 시스템</code></p>

<h3 id="분산-데이터베이스의-투명성">분산 데이터베이스의 투명성</h3>

<table>
  <thead>
    <tr>
      <th>투명성</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>분할 투명성</td>
      <td>고객은 하나의 논리적 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 여러 시스템에 저장되어 있을을 인식할 필요가 없음</td>
    </tr>
    <tr>
      <td>위치 투명성</td>
      <td>- 고객이 사용하려는 데이터의 저장 장소를 명시할 필요가 없음<br />- 고객은 데이터가 어느 위치에 있더라도 동일한 명령을 사용하여 데이터에 접근할 수 있어야 함</td>
    </tr>
    <tr>
      <td>지역 사상 투명성</td>
      <td>지역 DBMS와 물리적 데이터베이스 사이의 사상이 보장됨에 따라 각 지역 시스템 이름과 무관한 이름이 사용 가능</td>
    </tr>
    <tr>
      <td>중복 투명성</td>
      <td>데이터베이스 객체가 여러 시스템에 중복되어 존재함에도 고객과는 무관하게 데이터 일관성이 유지</td>
    </tr>
    <tr>
      <td>장애 투명성</td>
      <td>데이터베이스가 분산되어 있는 각 지역의 시스템이나 통신망에 이상이 발생해도, 데이터의 무결성은 보장</td>
    </tr>
    <tr>
      <td>병행 투명성</td>
      <td>여러 고객의 응용 프로그램이 동시에 분산 데이터베이스에 대한 트랜잭션을 수행하는 경우에도 결과에 이상이 없음</td>
    </tr>
  </tbody>
</table>

<h3 id="분산-데이터베이스-설계-방식">분산 데이터베이스 설계 방식</h3>

<ul>
  <li>상향식 설계 방식: 지역 스키마 작성 후 향후 전역 스키마를 작성하여 분산 데이터베이스 구축</li>
  <li>하향식 설계 방식: 전역 스키마 작성 후 해당 지역 사상 스키마를 작성하여 분산 데이터베이스 구축</li>
</ul>

<h3 id="분산-데이터베이스-장점과-단점">분산 데이터베이스 장점과 단점</h3>

<p>장점</p>

<ul>
  <li>데이터베이스 신뢰성과 가용성이 높음</li>
  <li>분산 데이터베이스가 병렬 처리를 수행하기에 빠른 응답 가능</li>
  <li>분산 데이터베이스를 추가하여 시스템 용량 확장이 쉬움</li>
</ul>

<p>단점</p>

<ul>
  <li>데이터베이스가 여러 네트워크를 통해 분리되어 있기에 관리와 통제가 어려움</li>
  <li>보안관리가 어려움</li>
  <li>데이터 무결성 관리가 어려움</li>
  <li>데이터베이스 설계가 복잡</li>
</ul>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[데이터 베이스 정규화 작업]]></summary></entry><entry><title type="html">데이터 모델링</title><link href="http://localhost:4000/database/2023/06/04/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81.html" rel="alternate" type="text/html" title="데이터 모델링" /><published>2023-06-04T06:00:01+09:00</published><updated>2023-06-04T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/04/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81</id><content type="html" xml:base="http://localhost:4000/database/2023/06/04/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81.html"><![CDATA[<h2 id="데이터-모델링">데이터 모델링</h2>

<hr />

<p>현실 세계를 데이터베이스로 표현하기 위해 추상화하는 작업</p>

<h3 id="데이터-모델링의-특징">데이터 모델링의 특징</h3>

<table>
  <thead>
    <tr>
      <th>특징</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>추상화(Abstraction)</td>
      <td>현실 세계를 간략하게 표현한다.</td>
    </tr>
    <tr>
      <td>단순화(Simplification)</td>
      <td>누구나 쉽게 이해할 수 있도록 표현한다.</td>
    </tr>
    <tr>
      <td>명확성(Clarity)</td>
      <td>명확하게 의미가 해석되어야 하고 한 가지 의미를 가져야 한다.</td>
    </tr>
  </tbody>
</table>

<h3 id="데이터-모델링-단계">데이터 모델링 단계</h3>

<table>
  <thead>
    <tr>
      <th>데이터 모델링 단계</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>개념적 모델링</td>
      <td>- 전사적 관점에서 기업의 데이터를 모델링<br />- 추상화 수준이 가장 높은 수준의 모델링<br />- 계층형 데이터 모델, 네트워크 모델, 관계형 모델에 관계없이 업무 측면에서 모델링</td>
    </tr>
    <tr>
      <td>논리적 모델링</td>
      <td>- 특정 데이터베이스 모델에 종속<br />- 식별자를 정의하고 관계, 속성 등을 모두 표현<br />- 정규화를 통해 재사용성을 높임</td>
    </tr>
    <tr>
      <td>물리적 모델링</td>
      <td>- 구축할 데이터베이스 관리 시스템에 테이블, 인덱스 등을 생성하는 단계<br />- 성능, 보안, 가용성 등을 고려하여 데이터베이스 구축</td>
    </tr>
  </tbody>
</table>

<h3 id="데이터-모델링-관점">데이터 모델링 관점</h3>

<ul>
  <li>데이터: 비즈니스 프로세스에서 사용되는 데이터</li>
  <li>프로세스: 비즈니스 프로세스에서 수행하는 작업</li>
  <li>데이터와 프로세스: 프로세스와 데이터 간의 관계</li>
</ul>

<h3 id="erd-작성-절차">ERD 작성 절차</h3>

<ol>
  <li>엔터티를 도출하고 그림</li>
  <li>엔터티를 배치</li>
  <li>엔터티 간의 관계 설정</li>
  <li>관계명 서술</li>
  <li>관계 참여도 표현</li>
  <li>관계의 필수 여부 표현</li>
</ol>

<h3 id="3층-스키마-구조">3층 스키마 구조</h3>

<ul>
  <li>외부 스키마: 사용자 관점으로 응용 프로그램이 접근하는 데이터베이스 정의</li>
  <li>개념 스키마: 설계자 관점으로 통합 데이터베이스 구조</li>
  <li>내부 스키마: 개발자 관점으로 데이터베이스의 물리적 저장 구조</li>
</ul>

<h3 id="엔터티-특징">엔터티 특징</h3>

<ul>
  <li>식별자: 엔터티는 유일한 식별자가 있어야 한다.</li>
  <li>인스턴스 집합: 2개 이상의 인스턴스가 있어야 한다.</li>
  <li>속성: 엔터티는 반드시 속성을 가지고 있다.</li>
  <li>관계: 엔터티는 다른 엔터티와 최소한 한 개 이상 관계가 있어야 한다.</li>
  <li>업무: 엔터티는 업무에서 관리되어야 하는 집합이다.</li>
</ul>

<h2 id="엔터티-종류">엔터티 종류</h2>

<hr />

<p>엔터티의 종류는 유형, 무형에 따른 종류, 엔터티가 발생하는 시점에 따른 종류로 나누어 짐</p>

<h3 id="유형과-무형에-따른-엔터티">유형과 무형에 따른 엔터티</h3>

<ul>
  <li>유형 엔터티: 업무에서 도출되며 지속적으로 사용되는 엔터티</li>
  <li>개념 엔터티: 유형 엔터티는 물리적 형태가 있지만, 개념 엔터티는 물리적 형태가 없음</li>
  <li>사건 엔터티: 비즈니스 프로세스를 실행하면서 생성되는 엔터티</li>
</ul>

<h3 id="발생-시점에-따른-엔터티-종류">발생 시점에 따른 엔터티 종류</h3>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>기본 엔터티</td>
      <td>-키 엔터티<br />- 다른 엔터티로부터 영향을 받지 않고 독립적으로 생성되는 엔터티</td>
    </tr>
    <tr>
      <td>중심 엔터티</td>
      <td>- 기본 엔터티와 행위 엔터티 간의 중간에 있는 것<br />- 기본 엔터티로부터 발생되고 행위 엔터티를 생성하는 것</td>
    </tr>
    <tr>
      <td>행위 엔터티</td>
      <td>- 2개 이상의 엔터티로부터 발생</td>
    </tr>
  </tbody>
</table>

<h2 id="속성attribute">속성(Attribute)</h2>

<hr />

<p>엔터티가 가지는 항목</p>

<h3 id="특징">특징</h3>

<ul>
  <li>업무에서 관리되는 정보</li>
  <li>하나의 값만 가짐</li>
  <li>주식별자에게 함수적으로 종속(기본키 변경시 속성 값도 변경)</li>
</ul>

<h3 id="종류">종류</h3>

<h3 id="분해-여부에-따른-속성의-종류">분해 여부에 따른 속성의 종류</h3>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>단일 속성</td>
      <td>하나의 의미로 구성된 것</td>
    </tr>
    <tr>
      <td>복합 속성</td>
      <td>여러 개의 의미가 있는 것</td>
    </tr>
    <tr>
      <td>다중값 속성</td>
      <td>속성에 여러 개의 값을 가질 수 있는 것</td>
    </tr>
  </tbody>
</table>

<h3 id="특성에-따른-속성의-종류">특성에 따른 속성의 종류</h3>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>기본 속성</td>
      <td>비즈니스 프로세스에서 도출되는 본래의 속성</td>
    </tr>
    <tr>
      <td>설계 속성</td>
      <td>데이터 모델링 과정에서 발생되는 속성, 유일한 값을 부여</td>
    </tr>
    <tr>
      <td>파생 속성</td>
      <td>다른 속성에 의해서 만들어지는 속성</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">도메인: 속성이 가질 수 있는 값의 범위</code></p>

<h2 id="관계relationship">관계(Relationship)</h2>

<hr />

<p>엔터티 간의 관련성</p>

<h3 id="관계의-종류">관계의 종류</h3>

<ul>
  <li>존재 관계: 엔터티 간의 상태를 의미</li>
  <li>행위 관계: 엔터티 간에 어떠한 행위가 있는 것</li>
</ul>

<h3 id="관계-차수">관계 차수</h3>

<p>두 개의 엔터티 간에 관계에 참여하는 수를 의미</p>

<h3 id="관계-차수-종류">관계 차수 종류</h3>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1대1 관계</td>
      <td>완전 1대1: 하나의 엔터티에 관계되는 엔터티의 관계가 하나인 경우로, 반드시 존재<br />선택적 1대1: 하나의 엔터티에 관계되는 엔터티의 관계가 하나이거나 없을 수도 있음</td>
    </tr>
    <tr>
      <td>1대N 관계</td>
      <td>엔터티에 행이 하나 있을 때 다른 엔터티의 값이 여러 개 있는 관계</td>
    </tr>
    <tr>
      <td>M대N 관계</td>
      <td>두 개 엔터티가 서로 여러 개의 관계를 가지고 있는 것</td>
    </tr>
    <tr>
      <td>필수적, 선택적 관계</td>
      <td>필수적 관계: 반드시 하나가 있어야 하는 관계<br />선택적 관계: 없을 수도 있는 관계</td>
    </tr>
  </tbody>
</table>

<h3 id="식별-관계와-비식별-관계">식별 관계와 비식별 관계</h3>

<p>식별 관계: 강한 개체의 기본키를 다른 엔터티의 기본키로 가지는 것</p>

<p>강한 개체(Strong Entity)</p>
<ul>
  <li>어떤 다른 엔터티에게 의존하지 않고 독립적으로 존재</li>
  <li>다른 엔터티와 관계를 가질 때 다른 엔터티에게 기본키를 공유함</li>
  <li>식별 관계로 표현</li>
  <li>기본키 값이 변경되면 식별 관계(기본키를 공유받은)에 있는 엔터티의 값도 변경</li>
  <li>강한 텐터티와 관계를 갖는 엔터티는 약한 개체(Weak Entity)가 됨</li>
</ul>

<p>비식별 관계: 강한 개체의 기본키를 다른 엔터티의 기본키가 아닌 일반 칼럼으로 관계를 가지는 것</p>

<h2 id="엔터티-식별자">엔터티 식별자</h2>
<hr />
<p>엔터티를 대표할 수 있는 유일성을 만족하는 속성</p>

<h3 id="키의-종류">키의 종류</h3>
<ul>
  <li>기본키(Primary key): 후보키 중에서 엔터티를 대표할 수 있는 키</li>
  <li>후보키(Candidate key): 유일성과 최소성을 만족하는 키</li>
  <li>슈퍼키(Super key): 유일성은 만족하지만 최소성을 만족하지 않는 키</li>
  <li>대체키(Alternate key): 여러 개의 후보키 중에서 기본키를 선정하고 남은 키</li>
  <li>외래키(Foreign key): 하나 혹은 다수의 다른 테이블의 기본 키 필드를 가리키는 것으로 참조 무결성을 확인하기 위해 사용되는 키</li>
</ul>

<h3 id="주식별자기본키-primary-key">주식별자(기본키, Primary key)</h3>
<ul>
  <li>최소성: 최소성을 만족하는 키</li>
  <li>대표성: 엔터티를 대표할 수 있어야 함</li>
  <li>유일성: 엔터티의 인스턴스를 유일하게 식별 가능</li>
  <li>불변성: 자주 변경되지 않아야 함</li>
</ul>

<h3 id="실별자의-종류">실별자의 종류</h3>
<p>식별자는 대표성, 생성 여부, 속성의 수, 대체 여부로 분류</p>

<h3 id="대표성-여부에-따른-식별자의-종류">대표성 여부에 따른 식별자의 종류</h3>
<ul>
  <li>주식별자: 유일성과 최소성을 만족하면서 엔터티를 대표하는 식별자로, 다른 엔터티와 참조 관계로 연결될 수 있음</li>
  <li>보조 식별자: 유일성과 최소성은 만족하지만 대표성을 만족하지 못하는 식별자</li>
</ul>

<h3 id="생성-여부에-따른-식별자의-종류">생성 여부에 따른 식별자의 종류</h3>
<ul>
  <li>내부 식별자: 엔터티 내부에서 스스로 생성되는 식별자</li>
  <li>외부 식별자: 다른 엔터티와의 관계로 인해 만들어지는 식별자</li>
</ul>

<h3 id="속성의-수에-따른-식별자의-종류">속성의 수에 따른 식별자의 종류</h3>
<ul>
  <li>단일 식별자: 하나의 속성으로 구성</li>
  <li>복합 식별자: 두 개 이상의 속성으로 구성</li>
</ul>

<h3 id="대체-여부에-따른-식별자의-종류">대체 여부에 따른 식별자의 종류</h3>
<ul>
  <li>본질 식별자: 비즈니스 프로세스에서 만들어지는 식별자</li>
  <li>인조 식별자: 인위적으로 만들어지는 식별자</li>
</ul>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[데이터 모델링 개념]]></summary></entry><entry><title type="html">QGIS3를 이용한 Shapefile 편집</title><link href="http://localhost:4000/qgis/2023/05/24/QGIS3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Shapefile-%ED%8E%B8%EC%A7%91.html" rel="alternate" type="text/html" title="QGIS3를 이용한 Shapefile 편집" /><published>2023-05-24T06:00:01+09:00</published><updated>2023-05-24T06:00:01+09:00</updated><id>http://localhost:4000/qgis/2023/05/24/QGIS3%EB%A5%BC%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20Shapefile%20%ED%8E%B8%EC%A7%91</id><content type="html" xml:base="http://localhost:4000/qgis/2023/05/24/QGIS3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Shapefile-%ED%8E%B8%EC%A7%91.html"><![CDATA[<h2 id="개요">개요</h2>

<hr />

<p>해당 포스트는 국토지리정보원의 정밀 도로지도(NGII)를 예로 들고 있음.<br /><br />
<a href="https://hhh57463.github.io/qgis/2023/05/22/QGIS3-%EC%82%AC%EC%9A%A9%EB%B2%95.html">QGIS3 사용법</a></p>

<h2 id="shapefile-편집">Shapefile 편집</h2>

<hr />

<h3 id="편집모드">편집모드</h3>

<p>shapefile을 수정할 때는 항상 편집모드가 켜져야한다. 이는 QGIS3의 상단바에 <code class="language-plaintext highlighter-rouge">편집 모드 전환</code> 을 이용하여 켤 수 있다.</p>

<p><img src="/assets/img/QGIS3/edit_1.png" alt="Image" /></p>

<p>편집 모드를 켜면 특정 기능들을 사용할 수 있게 버튼들이 활성화 된다.</p>

<p><img src="/assets/img/QGIS3/edit_2.png" alt="Image" /></p>

<table>
  <thead>
    <tr>
      <th>아이콘</th>
      <th>기능</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/save.png" alt="Image" /></td>
      <td>레이어 편집 내용 저장</td>
      <td>해당 레이어에서 변경된 점을 저장한다.</td>
    </tr>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/add.png" alt="Image" /></td>
      <td>객체 추가</td>
      <td>해당 레이어에 맞는 Shape Type을 추가한다.</td>
    </tr>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/compass.png" alt="Image" /></td>
      <td>꼭짓점 도구</td>
      <td>현재 있는 객체의 꼭짓점을 기준으로 객체를 수정한다.</td>
    </tr>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/alledit.png" alt="Image" /></td>
      <td>선택한 모든 객체의 속성을 동시에 수정</td>
      <td>선택한 모든 객체를 동일한 값으로 수정할 수 있다.</td>
    </tr>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/delete.png" alt="Image" /></td>
      <td>선택 삭제</td>
      <td>선택한 객체를 제거한다.</td>
    </tr>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/cut.png" alt="Image" /></td>
      <td>잘라내기</td>
      <td>선택한 객체를 잘라낸다.</td>
    </tr>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/copy.png" alt="Image" /></td>
      <td>객체 복사</td>
      <td>선택한 객체를 복사한다.</td>
    </tr>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/paste.png" alt="Image" /></td>
      <td>객체 붙여넣기</td>
      <td>복사한 객체를 붙여넣는다.</td>
    </tr>
  </tbody>
</table>

<h2 id="데이터-수정">데이터 수정</h2>

<hr />

<h3 id="데이터-속성값-수정">데이터 속성값 수정</h3>

<p><code class="language-plaintext highlighter-rouge">이는 .shp를 수정하는 것이 아닌 .dbf의 요소를 수정하는 작업이다.</code></p>

<p>편집 모드가 켜진 상태에서 객체를 식별해준다.</p>

<p><img src="/assets/img/QGIS3/edit_3.png" alt="Image" /></p>

<p>식별 결과 탭에 상단에 있는 <code class="language-plaintext highlighter-rouge">객체 양식 편집</code> 버튼을 선택하여 객체 속성을 수정할 수 있다.</p>

<p><img src="/assets/img/QGIS3/edit_4.png" alt="Image" /></p>

<h2 id="shapefile-수정">Shapefile 수정</h2>

<hr />

<h3 id="데이터-수정-1">데이터 수정</h3>

<p>상단 바 중 <code class="language-plaintext highlighter-rouge">영역 또는 단일 클릭으로 객체 선택</code> 버튼을 선택한다.</p>

<p><img src="/assets/img/QGIS3/edit_5.png" alt="Image" /></p>

<p><img src="/assets/img/QGIS3/edit_6.png" alt="Image" /></p>

<p>해당 상태로 객체를 선택해주면 객체 위에 X표시가 나타난다</p>

<p>상단 탭의 <code class="language-plaintext highlighter-rouge">꼭짓점 도구</code> 를 선택하여 Drag &amp; Drop 하면 해당 꼭짓점의 객체를 이동시킬 수 있다.</p>

<p><img src="/assets/img/QGIS3/shapefile_edit_1.gif" alt="Image" /></p>

<p><code class="language-plaintext highlighter-rouge">Point형의 객체를 선택하면 해당 Point를 이동시킬 수 있다.</code></p>

<p>만약 PolyLine의 Point(지점)을 제거하고 싶다면 객체를 선택한 후 x표시가 나타난 상태에서 해당 객체를 우클릭하면 <code class="language-plaintext highlighter-rouge">꼭짓점 편집기</code> 가 켜진다.</p>

<p><img src="/assets/img/QGIS3/edit_7.png" alt="Image" /></p>

<p>꼭짓점 편집기에서 특정 튜플을 선택하면 객체에도 표시가 되는데 이 상태에서 <code class="language-plaintext highlighter-rouge">Delete</code> 키를 눌러주면 해당 꼭짓점을 삭제할 수 있다.</p>

<h3 id="데이터-삽입">데이터 삽입</h3>

<p>편집 모드 전환을 선택한 상태로 상단바의 <code class="language-plaintext highlighter-rouge">객체 추가</code> 버튼을 선택한다.</p>

<p><img src="/assets/img/QGIS3/shapefile_edit_2.gif" alt="Image" /></p>

<p>마우스 좌클릭으로 꼭짓점을 지정한 후 마우스 우클릭으로 완료해준다.</p>

<p><code class="language-plaintext highlighter-rouge">현재는 선택한 레이어가 PolyLine Type이기 때문에 꼭짓점을 지정해주어야 한다, 선택한 레이어가 Point Type일 시 Point의 위치를 지정해주면 된다.</code></p>

<p>.shp 데이터를 추가했으니 .dbf에 맞는 속성도 정의해 준 후 확인 버튼을 클릭하면 데이터가 추가된다.</p>

<p><img src="/assets/img/QGIS3/edit_8.png" alt="Image" /></p>

<p>해당 객체를 식별 해보면 입력한 속성 값이 들어간 것을 볼 수 있다.</p>

<h2 id="데이터-저장">데이터 저장</h2>

<hr />

<p>모든 편집이 종료되면 레이어 편집 내용 저장을 통해 변경된 내용을 저장해야 한다.</p>

<p><img src="/assets/img/QGIS3/edit_9.png" alt="Image" /></p>]]></content><author><name>Mindol</name></author><category term="QGIS" /><category term="QGIS" /><category term="shapefile" /><summary type="html"><![CDATA[Shapefile edit]]></summary></entry><entry><title type="html">QGIS3 사용법</title><link href="http://localhost:4000/qgis/2023/05/23/QGIS3-%EC%82%AC%EC%9A%A9%EB%B2%95.html" rel="alternate" type="text/html" title="QGIS3 사용법" /><published>2023-05-23T06:00:01+09:00</published><updated>2023-05-23T06:00:01+09:00</updated><id>http://localhost:4000/qgis/2023/05/23/QGIS3%20%EC%82%AC%EC%9A%A9%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/qgis/2023/05/23/QGIS3-%EC%82%AC%EC%9A%A9%EB%B2%95.html"><![CDATA[<h2 id="개요">개요</h2>

<hr />

<p>해당 포스트는 국토지리정보원의 정밀 도로지도(NGII)를 예로 들고 있음.</p>

<h2 id="qgis란">QGIS란?</h2>

<hr />

<p>QGIS: 공간데이터 조회, 편집, 분석 기능을 제공하는 대표적인 오픈소스 데스크탑 지리정보시스템(GIS) 소프트웨어.</p>

<p><a href="[https://www.qgis.org/ko/site/](https://www.qgis.org/ko/site/)">설치링크</a></p>

<h2 id="qgis3-사용법">QGIS3 사용법</h2>

<hr />

<h3 id="레이어-추가제거">레이어 추가/제거</h3>

<p>QGIS3를 실행하면 아래와 같은 화면이 시작된다.</p>

<p><img src="/assets/img/QGIS3/useage_1.png" alt="Image" /></p>

<p><img src="/assets/img/QGIS3/useage_2.png" alt="Image" /></p>

<p>QGIS3에 Shapefile(.shp)을 올리고 싶으면 좌하단 레이어 탭에 Shapefile을 Drag&amp;Drop한다.</p>

<p>특정 레이어를 제외하고 싶을 시 레이어 탭에서 해당 레이어의 이름 좌측 체크박스로 껏다 켤 수 있다.</p>

<p><img src="/assets/img/QGIS3/useage_3.png" alt="Image" /></p>

<p><code class="language-plaintext highlighter-rouge">A2_LINK의 체크박스 해제 후 모습</code></p>

<p><img src="/assets/img/QGIS3/useage_4.png" alt="Image" /></p>

<p>특정 레이어를 제거하고 싶을 시 레이어 선택 후 레이어 탭 중 상단 바에서 우측에 있는 <code class="language-plaintext highlighter-rouge">레이어/그룹 제거</code> 버튼을 클릭하거나, Ctrl + D를 사용하여 제거할 수 있다.</p>

<p>각 레이어의 심볼을 변경하고 싶을 경우 레이어 탭의 각 레이어를 더블클릭하여 수정할 수 있다.</p>

<p>변경할 수 있는 심볼은 각 레이어의 Shape Type에 맞는 심볼이 나온다.</p>

<p><img src="/assets/img/QGIS3/useage_5.png" alt="Image" /></p>

<p><code class="language-plaintext highlighter-rouge">Point Type의 Layer</code></p>

<p><img src="/assets/img/QGIS3/useage_6.png" alt="Image" /></p>

<p><code class="language-plaintext highlighter-rouge">PolyLine의 Layer</code></p>

<p>나는 각 레이어 식별을 쉽게하기 위해 색을 조정했다.</p>

<p><img src="/assets/img/QGIS3/useage_7.png" alt="Image" /></p>

<h3 id="데이터-조회">데이터 조회</h3>

<p>특정 데이터의 정보를 확인하기 위해서는 상단 바에서 객체 식별을 선택 후 확인해야한다.</p>

<p><img src="/assets/img/QGIS3/useage_8.png" alt="Image" /></p>

<p>‘A1_NODE’의 데이터를 확인하고 싶을 시, 레이어 탭에서 A1_NODE레이어를 선택 후 확인해야한다.</p>

<p><img src="/assets/img/QGIS3/useage_9.png" alt="Image" /></p>

<p>선택한 데이터는 식별 결과 탭에서 확인 가능하다.</p>

<p>특정 데이터의 속성을 검색하고 싶을 시 상단 바에서 <code class="language-plaintext highlighter-rouge">속성테이블 열기</code>를 클릭하거나 F6를 눌러 속성테이블을 켤 수 있다.</p>

<p><img src="/assets/img/QGIS3/useage_10.png" alt="Image" /></p>

<p><img src="/assets/img/QGIS3/useage_13.png" alt="Image" /></p>

<p>‘A1_NODE’의 속성 테이블</p>

<p><img src="/assets/img/QGIS3/useage_11.png" alt="Image" /></p>

<p>속성테이블의 상단 바에서 <code class="language-plaintext highlighter-rouge">서식을 이용해서 객체 선택/필터링</code> 을 선택하거나 Ctrl + F를 입력하여 검색란을 열 수 있다.</p>

<p><img src="/assets/img/QGIS3/useage_12.png" alt="Image" />
검색하려는 속성의 우측 <code class="language-plaintext highlighter-rouge">필드제외</code> 콤보박스를 클릭하면 검색 조건을 변경할 수 있다.</p>

<p>검색하려는 속성을 입력한 후 아래의 검색 방법 버튼을 클릭하여 특정 속성을 검색할 수 있다.</p>]]></content><author><name>Mindol</name></author><category term="QGIS" /><category term="QGIS" /><category term="shapefile" /><summary type="html"><![CDATA[QGIS3 useage]]></summary></entry><entry><title type="html">Shapefile Format</title><link href="http://localhost:4000/study/2023/05/19/%EA%B3%B5%EB%B6%80-Shapefile-Format.html" rel="alternate" type="text/html" title="Shapefile Format" /><published>2023-05-19T06:00:01+09:00</published><updated>2023-05-19T06:00:01+09:00</updated><id>http://localhost:4000/study/2023/05/19/%5B%EA%B3%B5%EB%B6%80%5DShapefile%20Format</id><content type="html" xml:base="http://localhost:4000/study/2023/05/19/%EA%B3%B5%EB%B6%80-Shapefile-Format.html"><![CDATA[<h1 id="개요">개요</h1>
<hr />
<p>교내 연구실에서 연구 진행 중 Shapefile format 분석을 의뢰받아 정리하여 요약</p>

<h2 id="목차">목차</h2>

<hr />

<ol>
  <li>shapefile이란?</li>
  <li>Little Endian, Big Endian</li>
  <li>shapefile 구성요소</li>
</ol>

<h2 id="shapefile이란">Shapefile이란?</h2>

<hr />

<p>.shp를 확장자로 가지며, 벡터방식으로 공간정보를 저장하는 파일.</p>

<p>shapefile은 점(Point), 선(Line), 면(Polygon) 중 하나의 속성을 가지며, shapefile에서 면(Polygon)을 잘라내거나 합칠 수 있다.</p>

<p>shapefile은 서로 다른 확장명을 가진 세 개 이상의 파일로 구성되는데</p>

<ul>
  <li>.shp - 피처의 지오메트리(형상)을 저장하는 기본파일</li>
  <li>.shx - 피처의 기하학의 색인을 저장하는 인덱스 파일</li>
  <li>.dbf - 피처의 속성 정보를 저장하는 dBASE 테이블</li>
</ul>

<p>이들을 구성 요소 파일이라 부른다.</p>

<p>위의 3개의 파일을 main file이라 칭하며 그 외에는 아래의 파일이 존재.</p>

<ul>
  <li>.prj - 지리 좌표를 알려주는 파일</li>
  <li>.sbn - 지리 공간 인덱스를 저장하는 파일</li>
  <li>.sbx - spatial join의 기능을 수행하거나 shape 필드에 대한 인덱스 생성에 필요한 파일</li>
</ul>

<p>*spatial join (공간결합): 두 공간 데이터프레임을 결합(merge)하는데, key 값이 아닌 위치정보에 따라 결합(overlay)해주는 방식.</p>

<h2 id="little-endian-big-endian">Little Endian, Big Endian</h2>

<hr />

<p>컴퓨터는 데이터를 메모리에 저장할 때 byte 단위로 나누어 저장하지만, 컴퓨터가 저장하는 데이터는 대게 32bit(4byte)나 64bit(8byte)로 구성된다.</p>

<p>따라서 연속되는 byte를 순서대로 저장해야 하는데, 이것을 바이트 저장 순서(byte order)라고 함.</p>

<p>바이트가 저장되는 순서에 따라 두 가지 방법으로 나눌 수 있다.</p>

<ul>
  <li>리틀 엔디안(Little Endian)</li>
  <li>빅 엔디안(Big Endian)</li>
</ul>

<h3 id="little-endian">Little Endian</h3>

<p>낮은 주소에 데이터의 낮은 바이트(LSB, Least Significant Bit)부터 저장하는 방식.</p>

<p>이 방식은 평소 우리가 숫자를 사용하는 선형 방식과는 반대로 거꾸로 읽어야 한다.</p>

<p>대부분 인텔 CPU 계열에서 이 방식으로 데이터를 저장함.</p>

<p>0x12345678을 저장해야 할 경우 이 정수는 0x12, 0x34, 0x56, 0x78로 1byte 값 4개로 구성됨.</p>

<p>이 4개의 1byte 값을 Big Endian 방식으로 저장되면 그림과 같이 저장됨.</p>

<p><img src="/assets/img/Shapefile/Shapefile_1.png" alt="리틀 엔디안 저장 방식" /></p>

<h3 id="big-endian">Big Endian</h3>

<p>낮은 주소에 데이터의 높은 바이트(MSB, Most Significant Bit)부터 저장하는 방식.</p>

<p>평소 우리가 숫자를 사용하는 선형 방식과 같은 방식.</p>

<p>메모리에 저장된 순서 그대로 읽을 수 있으며, 이해하기 쉽다는 장점을 가짐.</p>

<p>SPARC을 포함한 대부분의 RISC CPU 계열에서 이 방식으로 데이터를 저장함.</p>

<p>0x12345678을 저장해야 할 경우 이 정수는 0x12, 0x34, 0x56, 0x78로 1byte 값 4개로 구성됨.</p>

<p>이 4개의 1byte 값을 Big Endian 방식으로 저장되면 그림과 같이 저장됨.</p>

<p><img src="/assets/img/Shapefile/Shapefile_2.png" alt="빅 엔디안 저장 방식" /></p>

<h3 id="리틀-엔디안-vs-빅-엔디안">리틀 엔디안 vs 빅 엔디안</h3>

<p>빅 엔디안과 리틀 엔디안은 단지 저장해야 할 큰 데이터를 어떻게 나누어 저장하는가에 따른 차이일 뿐, 어느 방식이 더 우수하다고는 단정할 수 없음.</p>

<p>물리적으로 데이터를 조작하거나 산술 연산을 수행할 때에는 리틀 엔디안 방식이 더 효율적이지만,데이터의 각 바이트를 배열처럼 취급할 때에는 빅 엔디안 방식이 더 적합.</p>

<p>대부분의 시스템은 인텔 기반의 윈도우이므로 리틀 엔디안 방식을 사용.</p>

<p>네트워크를 통해 데이터를 전송할 때에는 빅 엔디안 방식이 사용.</p>

<p>인텔 기반의 시스템에서 소켓 통신을 할 때는 바이트 순서에 신경을 써서 데이터를 전달해야 함.</p>

<h2 id="shapefile-구성요소">Shapefile 구성요소</h2>

<hr />

<p>shapefile은 다음과 같이 구성됨.</p>

<p><img src="/assets/img/Shapefile/Shapefile_3.png" alt="Shapefile 구성요소" /></p>

<h3 id="file-header-구성">File Header 구성</h3>

<table>
  <thead>
    <tr>
      <th>Position</th>
      <th>Field</th>
      <th>Value</th>
      <th>Type</th>
      <th>Byte Order</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Byte 0</td>
      <td>File Code</td>
      <td>9994</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 4</td>
      <td>Unused</td>
      <td>0</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 8</td>
      <td>Unused</td>
      <td>0</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 12</td>
      <td>Unused</td>
      <td>0</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 16</td>
      <td>Unused</td>
      <td>0</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 20</td>
      <td>Unused</td>
      <td>0</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 24</td>
      <td>File Length</td>
      <td>File Length</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 28</td>
      <td>Version</td>
      <td>1000</td>
      <td>Integer</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 32</td>
      <td>Shape Type</td>
      <td>Shape Type</td>
      <td>Integer</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 36</td>
      <td>Bounding Box</td>
      <td>Xmin</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 44</td>
      <td>Bouding Box</td>
      <td>Ymin</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 52</td>
      <td>Bounding Box</td>
      <td>Xmax</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 60</td>
      <td>Bouding Box</td>
      <td>Ymax</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 68*</td>
      <td>Bounding Box</td>
      <td>Zmin</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 76*</td>
      <td>Bouding Box</td>
      <td>Zmax</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 84*</td>
      <td>Bounding Box</td>
      <td>Mmin</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 92*</td>
      <td>Bouding Box</td>
      <td>Mmax</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
  </tbody>
</table>

<p>Bounding Box란 해당 SHP 파일의 MBR(Minimum Bounding Rectangle)을 의미.</p>

<p>*MBR: 여러 점으로 구성되어 있을 경우 해당 점을 둘러싸고 있는 가장  작은 사각형으로, 해당 개체가 포함된 지도상의 위치를 대략적으로 표시하는 정보를 가짐.</p>

<h3 id="shape-type">Shape Type</h3>

<p>File Header구성 중 Byte32에 위치한 Shape Type은 이름당 값이 지정되어 있으며, 아래와 같다.</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NULL</td>
      <td>0</td>
    </tr>
    <tr>
      <td>POINT</td>
      <td>1</td>
    </tr>
    <tr>
      <td>ARC</td>
      <td>3</td>
    </tr>
    <tr>
      <td>POLYGON</td>
      <td>5</td>
    </tr>
    <tr>
      <td>MULTIPOINT</td>
      <td>8</td>
    </tr>
    <tr>
      <td>POINTZ</td>
      <td>11</td>
    </tr>
    <tr>
      <td>ARCZ</td>
      <td>13</td>
    </tr>
    <tr>
      <td>POLYGONZ</td>
      <td>15</td>
    </tr>
    <tr>
      <td>MULTIPOINTZ</td>
      <td>18</td>
    </tr>
    <tr>
      <td>POINTM</td>
      <td>21</td>
    </tr>
    <tr>
      <td>ARCM</td>
      <td>23</td>
    </tr>
    <tr>
      <td>POLYGONM</td>
      <td>25</td>
    </tr>
    <tr>
      <td>MULTIPOINTM</td>
      <td>28</td>
    </tr>
    <tr>
      <td>MULTIPATCH</td>
      <td>31</td>
    </tr>
  </tbody>
</table>

<p>SHP 포맷은 한 파일에 하나의 Shape Type만을 수용한다. 따라서 Point와 Line이 같은 파일에 있을 수 없다.</p>

<h3 id="record-header">Record Header</h3>

<table>
  <thead>
    <tr>
      <th>Position</th>
      <th>Field</th>
      <th>Value</th>
      <th>Type</th>
      <th>Order</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Byte 0</td>
      <td>Record Number</td>
      <td>Record Number</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 4</td>
      <td>Content Length</td>
      <td>Content Length</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
  </tbody>
</table>

<p>Record Header는 거의 사용되지 않음.(.shx 파일을 이용해 shp를 포인팅할 수 있기 때문)</p>

<h3 id="record-contents">Record Contents</h3>

<p>Record Contents는 실제 점(Point), 선(Line), 면(Polygon)이 기록되어 있으며, Shape Type에 따라 달라짐.</p>

<p>ShapeType - Point</p>

<table>
  <thead>
    <tr>
      <th>Position</th>
      <th>Field</th>
      <th>Value</th>
      <th>Type</th>
      <th>Number</th>
      <th>Order</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Byte 0</td>
      <td>Shape Type</td>
      <td>1</td>
      <td>Integer</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 4</td>
      <td>X</td>
      <td>X</td>
      <td>Double</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 12</td>
      <td>Y</td>
      <td>Y</td>
      <td>Double</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
  </tbody>
</table>

<p>Point는 double로 된 x, y로 구성되어 있는 값.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Point</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ShapeType - Multi Point</p>

<p>Multi Point(다중 포인트)는 여러 개의 점을 하나의 개체로 인식하는 것. 위치가 다른 곳에 있는 점이라도 같은 속성을 지니고 있을 경우 이들을 하나로 묶어서 사용하기 좋음</p>

<table>
  <thead>
    <tr>
      <th>Position</th>
      <th>Field</th>
      <th>Value</th>
      <th>Type</th>
      <th>Number</th>
      <th>Order</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Byte 0</td>
      <td>Shape Type</td>
      <td>8</td>
      <td>Integer</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 4</td>
      <td>Box</td>
      <td>Box</td>
      <td>Double</td>
      <td>4</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 36</td>
      <td>NumPoints</td>
      <td>NumPoints</td>
      <td>Integer</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 40</td>
      <td>Points</td>
      <td>Points</td>
      <td>Point</td>
      <td>NumPoints</td>
      <td>Little Endian</td>
    </tr>
  </tbody>
</table>

<p>Byte 4에 위치한 Box 또한 MBR.</p>

<p>Byte 36의 NumPoints는 개체가 가지는 점(Point)의 개수를 나타내며, Multi Point는 여러 개의 점을 하나의 개체로 묶은 것이기 때문에, 개체당 점이 하나 이상 존재할 수 있음.</p>

<p>Byte 40부터는 개체 내에 실제로 포함된 점(Point)들을 담고 있는 것으로, 개체당 하나 이상의 점이 존재할 수 있으므로, NumPoints만큼의 Point가 나열됨.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">MultiPoint</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">Box</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">NumPoints</span><span class="p">;</span>
  <span class="n">Point</span><span class="p">[</span><span class="n">NumPoints</span><span class="p">]</span> <span class="n">Points</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ShapeType - PolyLine, Arc</p>

<p>아크는 Line 혹은 PolyLine을 수용하는 구조체로, 다중 포인트처럼 위치가 다른 곳에 있는 선을 같은 개체로 처리할 수 있음.</p>

<table>
  <thead>
    <tr>
      <th>Position</th>
      <th>Field</th>
      <th>Value</th>
      <th>Type</th>
      <th>Number</th>
      <th>Order</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Byte 0</td>
      <td>Shape Type</td>
      <td>3</td>
      <td>Integer</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 4</td>
      <td>Box</td>
      <td>Box</td>
      <td>Double</td>
      <td>4</td>
      <td>Litle Endian</td>
    </tr>
    <tr>
      <td>Byte 36</td>
      <td>NumParts</td>
      <td>NumParts</td>
      <td>Integer</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 40</td>
      <td>NumPoints</td>
      <td>NumPoints</td>
      <td>Integer</td>
      <td>1</td>
      <td>Litle Endian</td>
    </tr>
    <tr>
      <td>Byte 44</td>
      <td>Parts</td>
      <td>Parts</td>
      <td>Integer</td>
      <td>NumParts</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte X</td>
      <td>Points</td>
      <td>Points</td>
      <td>Point</td>
      <td>NumParts</td>
      <td>Litle Endian</td>
    </tr>
  </tbody>
</table>

<p>*Part: 한 Arc 개체에 몇 개의 PolyLine이 존재하는지</p>

<p>Byte 4의 Box 역시 MBR을 의미</p>

<p>Byte 36의 NumParts는 Arc 개체에 속한 PolyLine 개체의 수를 나타내며, Byte 40의 NumPoints는 해당 Arc 개체에 포함된 전체 점의 수를 의미.</p>

<p>Byte 40의 NumPoints는 개체에 있는 점의 수를 의미, 위치나 Part와 관계없이 저장되며 점의 개수가 몇 개인지 지정하는 것.</p>

<p>Byte 44의 Parts는 각각의 PolyLine 개체가 몇 개의 점으로 이루어져 있는지를 나타내며, 이를 통해 어느 부분이 어떤 PolyLine에 속하는지를 파악할 수 있음.</p>

<p>Byte X의 Points는 각 점의 위치를 나타내며, PolyLine 개체의 경우는 순서대로 각 점의 위치가 저장되며, Arc 개체의 경우는 여러 개의 PolyLine으로 이루어져 있으므로 Parts 정보를 통해 어느 PolyLine에 속하는지를 파악한 후 해당 PolyLine에 속한 각 점의 위치가 순서대로 저장됨.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">PolyLine</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">Box</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">NumParts</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">NumPoints</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">Parts</span><span class="p">[</span><span class="n">NumParts</span><span class="p">];</span>
  <span class="n">Point</span><span class="p">[</span><span class="n">NumPoints</span><span class="p">]</span> <span class="n">Points</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ShapeType - Polygon</p>

<p>Polygon은 PolyLine 혹은 Arc의 구조와 같지만 파트별로 시작점과 끝점이 같아서 닫혀있다는 것을 강조.</p>

<table>
  <thead>
    <tr>
      <th>Position</th>
      <th>Field</th>
      <th>Value</th>
      <th>Type</th>
      <th>Number</th>
      <th>Order</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Byte 0</td>
      <td>Shape Type</td>
      <td>5</td>
      <td>Integer</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 4</td>
      <td>Box</td>
      <td>Box</td>
      <td>Double</td>
      <td>4</td>
      <td>Litle Endian</td>
    </tr>
    <tr>
      <td>Byte 36</td>
      <td>NumParts</td>
      <td>NumParts</td>
      <td>Integer</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 40</td>
      <td>NumPoints</td>
      <td>NumPoints</td>
      <td>Integer</td>
      <td>1</td>
      <td>Litle Endian</td>
    </tr>
    <tr>
      <td>Byte 44</td>
      <td>Parts</td>
      <td>Parts</td>
      <td>Integer</td>
      <td>NumParts</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte X</td>
      <td>Points</td>
      <td>Points</td>
      <td>Point</td>
      <td>NumParts</td>
      <td>Litle Endian</td>
    </tr>
  </tbody>
</table>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Polygon</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">Box</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">NumParts</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">NumPoints</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">Parts</span><span class="p">[</span><span class="n">NumParts</span><span class="p">];</span>
  <span class="n">Point</span><span class="p">[</span><span class="n">NumPoints</span><span class="p">]</span> <span class="n">Points</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="출처-및-참고">출처 및 참고</h3>
<hr />
<p><a href="https://yganalyst.github.io/spatial_analysis/spatial_analysis_4/">[GIS] 공간 데이터 결합(Spatial Join)</a></p>

<p><a href="http://www.tcpschool.com/c/c_refer_endian">코딩교육 티씨피스쿨</a></p>

<p><a href="https://velog.io/@cha-suyeon/QGIS-알아가기-shapefile이란-무엇일까.shp">QGIS 알아가기 - shapefile이란 무엇일까?(.shp)</a></p>

<p><a href="https://endofcap.tistory.com/3">[SHPViewer 강좌 1] SHP 포맷 분석 1</a></p>

<p><a href="https://docs.fileformat.com/gis/shp/">SHP - ESRI Shapefile</a></p>]]></content><author><name>Mindol</name></author><category term="Study" /><category term="study" /><category term="shapefile" /><summary type="html"><![CDATA[shapefile format]]></summary></entry></feed>