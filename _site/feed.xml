<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-06-06T00:24:29+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Mindol</title><subtitle>Mindol&apos;s Blog</subtitle><author><name>Mindol</name></author><entry><title type="html">정규화</title><link href="http://localhost:4000/database/2023/06/05/%EC%A0%95%EA%B7%9C%ED%99%94.html" rel="alternate" type="text/html" title="정규화" /><published>2023-06-05T06:00:01+09:00</published><updated>2023-06-05T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/05/%EC%A0%95%EA%B7%9C%ED%99%94</id><content type="html" xml:base="http://localhost:4000/database/2023/06/05/%EC%A0%95%EA%B7%9C%ED%99%94.html"><![CDATA[<h2 id="정규화normalization">정규화(Normalization)</h2>

<hr />

<ul>
  <li>데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이며 데이터를 분해하는 과정</li>
  <li>중복을 제거하고 데이터 모델의 독립성을 확보하기 위한 방법</li>
  <li>테이블을 분해해서 데이터 중복을 제거하기 때문에 데이터 모델의 유연성을 높임</li>
  <li>정규화 수행시 비즈니스에 변화가 발생하여도 데이터 모델의 변경을 최소화할 수 있음</li>
  <li>제1정규화부터 제5정규화까지 있지만, 실질적으로 제3정규화까지만 수행</li>
</ul>

<h3 id="정규화-절차">정규화 절차</h3>

<table>
  <thead>
    <tr>
      <th>정규화 절차</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>제1정규화</td>
      <td>- 속성의 원자성 확보<br />- 기본키 설정</td>
    </tr>
    <tr>
      <td>제2정규화</td>
      <td>- 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거(분해)<br />- 기본키가 하나의 칼럼으로 이루어지면 제2정규화는 생략</td>
    </tr>
    <tr>
      <td>제3정규화</td>
      <td>- 기본키를 제외한 칼럼 간에 종속성을 제거<br />- 이행 함수 종속성을 제거</td>
    </tr>
    <tr>
      <td>BCNF</td>
      <td>기본키를 제외하고 후보키가 있는 경우, 후보키가 기본키를 종속시키면 분해</td>
    </tr>
    <tr>
      <td>제4정규화</td>
      <td>여러 칼럼들이 하나의 칼럼을 종속시키는 경우 분해하여 다중값 종속성 제거</td>
    </tr>
    <tr>
      <td>제5정규화</td>
      <td>조인에 의해 종속성이 발생되는 경우 분해</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">정규화의 문제점: 정규화는 데이터 조회(SELECT) 시에 조인(Join)을 유발하기에 CPU와 메모리를 많이 사용.</code></p>

<h2 id="반정규화de-normalization">반정규화(De-Normalization)</h2>

<hr />

<p>데이터베이스의 성능 향상을 위해 데티어 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법</p>

<p>조회(SELECT) 속도를 향상하지만, 데이터 모델의 유연성은 낮아짐</p>

<h3 id="반정규화를-수행하는-경우">반정규화를 수행하는 경우</h3>

<ul>
  <li>정규화에 충실하면 종속성, 활용성은 향상되지만 숙도가 느려지는 경우</li>
  <li>다량의 범위를 자주 처리해야 하는 경우</li>
  <li>특정 범위의 데이터만 자주 처리하는 경우</li>
  <li>요약/집계 정보가 자주 요구되는 경우</li>
</ul>

<h3 id="반정규화-절차">반정규화 절차</h3>

<ul>
  <li>대상 조사 및 검토: 데이터 처리 범위, 통계성 등을 확인해서 반정규화 대상 조사</li>
  <li>다른 방법 검토: 반정규화를 수행하기 전에 다른 방법이 있는지 검토(클러스터링, 뷰, 인덱스 튜닝, 응용프로그램, 파티션 검토)</li>
  <li>반정규화 수행: 테이블, 속성, 관계 등을 반정규화</li>
</ul>

<h3 id="반정규화-기법">반정규화 기법</h3>

<ul>
  <li>계산된 칼럼 추가</li>
  <li>테이블 수직 분할: 하나의 테이블을 두 개 이상의 테이블로 분할 (칼럼을 분할하여 새로운 테이블 생성)</li>
  <li>테이블 수평 분할: 하나의 테이블에 있는 값을 기준으로 테이블 분할</li>
  <li>테이블 병합: 테이블을 하나의 테이블로 병합하여 성능 향상</li>
</ul>

<h3 id="파티션partition-기법">파티션(Partition) 기법</h3>

<p>데이터베이스에서 파티션을 사용하여 테이블을 분할할 수 있음.</p>

<p>파티션을 사용하면 논리적으로는 하나의 테이블이지만 여러 개의 데이터 파일에 분산되어 저장됨.</p>

<table>
  <thead>
    <tr>
      <th>기법</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Range Partition</td>
      <td>데이터 값의 범위를 기준으로 파티션 수행</td>
    </tr>
    <tr>
      <td>List Partition</td>
      <td>특정한 값을 지정하여 파티션 수행</td>
    </tr>
    <tr>
      <td>Hash Partition</td>
      <td>해시 함수를 적용하여 파티션 수행</td>
    </tr>
    <tr>
      <td>Composite Partition</td>
      <td>범위와 해시를 복합적으로 사용하여 파티션 수행</td>
    </tr>
  </tbody>
</table>

<p>파티션 테이블의 장점</p>

<ul>
  <li>데이터 조회 시 액세스 범위가 줄어들기에 성능 향상</li>
  <li>데이터가 분할되어 있기에 I/O(Input/Output)의 성능 향상</li>
  <li>각 파티션을 독립적으로 백업 및 복구 가능</li>
</ul>

<h3 id="테이블-병합">테이블 병합</h3>

<ul>
  <li>1대1 관계의 테이블을 하나의 테이블로 병합하여 성능 향상</li>
  <li>1대N 관계의 테이블을 병합하여 성능 향상, 많은 양의 데이터 중복이 발생</li>
  <li>슈퍼 타입과 서브 타입 관계가 발생하면 테이블을 통합하여 성능 향상</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Super Type, Sub Type: 엔터티에 중복되는 값을 상속 Super Type은 부모, Sub Type은 자식으로 생각하면 됨</code></p>

<h3 id="슈퍼-타입-및-서브-타입-변환-방법">슈퍼 타입 및 서브 타입 변환 방법</h3>

<table>
  <thead>
    <tr>
      <th>변환 방법</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>OneToOne Type</td>
      <td>- 슈퍼 타입과 서브 타입을 개별 테이블로 도출<br />- 테이블의 수가 많아서 조인이 많이 발생하고 관리가 어려움</td>
    </tr>
    <tr>
      <td>Plus Type</td>
      <td>- 슈퍼 타입과 서브 타입 테이블로 도출<br />- 조인이 발생하고 관리가 어려움</td>
    </tr>
    <tr>
      <td>Single Type</td>
      <td>- 슈퍼 타입과 서브 타입을 하나의 테이블로 도출<br />- 조인 성능이 좋고 관리가 편하지만, 입출력 성능이 나쁨</td>
    </tr>
  </tbody>
</table>

<h2 id="분산-데이터베이스">분산 데이터베이스</h2>

<hr />

<ul>
  <li>중앙 집중형 데이터베이스: 한 대의 물리적 시스템에 DBMS를 설치하고 여러 명의 사용자가 DBMS에 접속하여 데이터베이스를 사용하는 구조</li>
  <li>분산 데이터베이스: 물리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스 이미지를 보여 주고 분산된 작업 처리를 수행하는 데이터베이스</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">DBMS: 데이터베이스 관리 시스템</code></p>

<h3 id="분산-데이터베이스의-투명성">분산 데이터베이스의 투명성</h3>

<table>
  <thead>
    <tr>
      <th>투명성</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>분할 투명성</td>
      <td>고객은 하나의 논리적 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 여러 시스템에 저장되어 있을을 인식할 필요가 없음</td>
    </tr>
    <tr>
      <td>위치 투명성</td>
      <td>- 고객이 사용하려는 데이터의 저장 장소를 명시할 필요가 없음<br />- 고객은 데이터가 어느 위치에 있더라도 동일한 명령을 사용하여 데이터에 접근할 수 있어야 함</td>
    </tr>
    <tr>
      <td>지역 사상 투명성</td>
      <td>지역 DBMS와 물리적 데이터베이스 사이의 사상이 보장됨에 따라 각 지역 시스템 이름과 무관한 이름이 사용 가능</td>
    </tr>
    <tr>
      <td>중복 투명성</td>
      <td>데이터베이스 객체가 여러 시스템에 중복되어 존재함에도 고객과는 무관하게 데이터 일관성이 유지</td>
    </tr>
    <tr>
      <td>장애 투명성</td>
      <td>데이터베이스가 분산되어 있는 각 지역의 시스템이나 통신망에 이상이 발생해도, 데이터의 무결성은 보장</td>
    </tr>
    <tr>
      <td>병행 투명성</td>
      <td>여러 고객의 응용 프로그램이 동시에 분산 데이터베이스에 대한 트랜잭션을 수행하는 경우에도 결과에 이상이 없음</td>
    </tr>
  </tbody>
</table>

<h3 id="분산-데이터베이스-설계-방식">분산 데이터베이스 설계 방식</h3>

<ul>
  <li>상향식 설계 방식: 지역 스키마 작성 후 향후 전역 스키마를 작성하여 분산 데이터베이스 구축</li>
  <li>하향식 설계 방식: 전역 스키마 작성 후 해당 지역 사상 스키마를 작성하여 분산 데이터베이스 구축</li>
</ul>

<h3 id="분산-데이터베이스-장점과-단점">분산 데이터베이스 장점과 단점</h3>

<p>장점</p>

<ul>
  <li>데이터베이스 신뢰성과 가용성이 높음</li>
  <li>분산 데이터베이스가 병렬 처리를 수행하기에 빠른 응답 가능</li>
  <li>분산 데이터베이스를 추가하여 시스템 용량 확장이 쉬움</li>
</ul>

<p>단점</p>

<ul>
  <li>데이터베이스가 여러 네트워크를 통해 분리되어 있기에 관리와 통제가 어려움</li>
  <li>보안관리가 어려움</li>
  <li>데이터 무결성 관리가 어려움</li>
  <li>데이터베이스 설계가 복잡</li>
</ul>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[데이터 베이스 정규화 작업]]></summary></entry><entry><title type="html">데이터 모델링</title><link href="http://localhost:4000/database/2023/06/04/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81.html" rel="alternate" type="text/html" title="데이터 모델링" /><published>2023-06-04T06:00:01+09:00</published><updated>2023-06-04T06:00:01+09:00</updated><id>http://localhost:4000/database/2023/06/04/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81</id><content type="html" xml:base="http://localhost:4000/database/2023/06/04/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%AA%A8%EB%8D%B8%EB%A7%81.html"><![CDATA[<h2 id="데이터-모델링">데이터 모델링</h2>

<hr />

<p>현실 세계를 데이터베이스로 표현하기 위해 추상화하는 작업</p>

<h3 id="데이터-모델링의-특징">데이터 모델링의 특징</h3>

<table>
  <thead>
    <tr>
      <th>특징</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>추상화(Abstraction)</td>
      <td>현실 세계를 간략하게 표현한다.</td>
    </tr>
    <tr>
      <td>단순화(Simplification)</td>
      <td>누구나 쉽게 이해할 수 있도록 표현한다.</td>
    </tr>
    <tr>
      <td>명확성(Clarity)</td>
      <td>명확하게 의미가 해석되어야 하고 한 가지 의미를 가져야 한다.</td>
    </tr>
  </tbody>
</table>

<h3 id="데이터-모델링-단계">데이터 모델링 단계</h3>

<table>
  <thead>
    <tr>
      <th>데이터 모델링 단계</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>개념적 모델링</td>
      <td>- 전사적 관점에서 기업의 데이터를 모델링<br />- 추상화 수준이 가장 높은 수준의 모델링<br />- 계층형 데이터 모델, 네트워크 모델, 관계형 모델에 관계없이 업무 측면에서 모델링</td>
    </tr>
    <tr>
      <td>논리적 모델링</td>
      <td>- 특정 데이터베이스 모델에 종속<br />- 식별자를 정의하고 관계, 속성 등을 모두 표현<br />- 정규화를 통해 재사용성을 높임</td>
    </tr>
    <tr>
      <td>물리적 모델링</td>
      <td>- 구축할 데이터베이스 관리 시스템에 테이블, 인덱스 등을 생성하는 단계<br />- 성능, 보안, 가용성 등을 고려하여 데이터베이스 구축</td>
    </tr>
  </tbody>
</table>

<h3 id="데이터-모델링-관점">데이터 모델링 관점</h3>

<ul>
  <li>데이터: 비즈니스 프로세스에서 사용되는 데이터</li>
  <li>프로세스: 비즈니스 프로세스에서 수행하는 작업</li>
  <li>데이터와 프로세스: 프로세스와 데이터 간의 관계</li>
</ul>

<h3 id="erd-작성-절차">ERD 작성 절차</h3>

<ol>
  <li>엔터티를 도출하고 그림</li>
  <li>엔터티를 배치</li>
  <li>엔터티 간의 관계 설정</li>
  <li>관계명 서술</li>
  <li>관계 참여도 표현</li>
  <li>관계의 필수 여부 표현</li>
</ol>

<h3 id="3층-스키마-구조">3층 스키마 구조</h3>

<ul>
  <li>외부 스키마: 사용자 관점으로 응용 프로그램이 접근하는 데이터베이스 정의</li>
  <li>개념 스키마: 설계자 관점으로 통합 데이터베이스 구조</li>
  <li>내부 스키마: 개발자 관점으로 데이터베이스의 물리적 저장 구조</li>
</ul>

<h3 id="엔터티-특징">엔터티 특징</h3>

<ul>
  <li>식별자: 엔터티는 유일한 식별자가 있어야 한다.</li>
  <li>인스턴스 집합: 2개 이상의 인스턴스가 있어야 한다.</li>
  <li>속성: 엔터티는 반드시 속성을 가지고 있다.</li>
  <li>관계: 엔터티는 다른 엔터티와 최소한 한 개 이상 관계가 있어야 한다.</li>
  <li>업무: 엔터티는 업무에서 관리되어야 하는 집합이다.</li>
</ul>

<h2 id="엔터티-종류">엔터티 종류</h2>

<hr />

<p>엔터티의 종류는 유형, 무형에 따른 종류, 엔터티가 발생하는 시점에 따른 종류로 나누어 짐</p>

<h3 id="유형과-무형에-따른-엔터티">유형과 무형에 따른 엔터티</h3>

<ul>
  <li>유형 엔터티: 업무에서 도출되며 지속적으로 사용되는 엔터티</li>
  <li>개념 엔터티: 유형 엔터티는 물리적 형태가 있지만, 개념 엔터티는 물리적 형태가 없음</li>
  <li>사건 엔터티: 비즈니스 프로세스를 실행하면서 생성되는 엔터티</li>
</ul>

<h3 id="발생-시점에-따른-엔터티-종류">발생 시점에 따른 엔터티 종류</h3>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>기본 엔터티</td>
      <td>-키 엔터티<br />- 다른 엔터티로부터 영향을 받지 않고 독립적으로 생성되는 엔터티</td>
    </tr>
    <tr>
      <td>중심 엔터티</td>
      <td>- 기본 엔터티와 행위 엔터티 간의 중간에 있는 것<br />- 기본 엔터티로부터 발생되고 행위 엔터티를 생성하는 것</td>
    </tr>
    <tr>
      <td>행위 엔터티</td>
      <td>- 2개 이상의 엔터티로부터 발생</td>
    </tr>
  </tbody>
</table>

<h2 id="속성attribute">속성(Attribute)</h2>

<hr />

<p>엔터티가 가지는 항목</p>

<h3 id="특징">특징</h3>

<ul>
  <li>업무에서 관리되는 정보</li>
  <li>하나의 값만 가짐</li>
  <li>주식별자에게 함수적으로 종속(기본키 변경시 속성 값도 변경)</li>
</ul>

<h3 id="종류">종류</h3>

<h3 id="분해-여부에-따른-속성의-종류">분해 여부에 따른 속성의 종류</h3>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>단일 속성</td>
      <td>하나의 의미로 구성된 것</td>
    </tr>
    <tr>
      <td>복합 속성</td>
      <td>여러 개의 의미가 있는 것</td>
    </tr>
    <tr>
      <td>다중값 속성</td>
      <td>속성에 여러 개의 값을 가질 수 있는 것</td>
    </tr>
  </tbody>
</table>

<h3 id="특성에-따른-속성의-종류">특성에 따른 속성의 종류</h3>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>기본 속성</td>
      <td>비즈니스 프로세스에서 도출되는 본래의 속성</td>
    </tr>
    <tr>
      <td>설계 속성</td>
      <td>데이터 모델링 과정에서 발생되는 속성, 유일한 값을 부여</td>
    </tr>
    <tr>
      <td>파생 속성</td>
      <td>다른 속성에 의해서 만들어지는 속성</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">도메인: 속성이 가질 수 있는 값의 범위</code></p>

<h2 id="관계relationship">관계(Relationship)</h2>

<hr />

<p>엔터티 간의 관련성</p>

<h3 id="관계의-종류">관계의 종류</h3>

<ul>
  <li>존재 관계: 엔터티 간의 상태를 의미</li>
  <li>행위 관계: 엔터티 간에 어떠한 행위가 있는 것</li>
</ul>

<h3 id="관계-차수">관계 차수</h3>

<p>두 개의 엔터티 간에 관계에 참여하는 수를 의미</p>

<h3 id="관계-차수-종류">관계 차수 종류</h3>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1대1 관계</td>
      <td>완전 1대1: 하나의 엔터티에 관계되는 엔터티의 관계가 하나인 경우로, 반드시 존재<br />선택적 1대1: 하나의 엔터티에 관계되는 엔터티의 관계가 하나이거나 없을 수도 있음</td>
    </tr>
    <tr>
      <td>1대N 관계</td>
      <td>엔터티에 행이 하나 있을 때 다른 엔터티의 값이 여러 개 있는 관계</td>
    </tr>
    <tr>
      <td>M대N 관계</td>
      <td>두 개 엔터티가 서로 여러 개의 관계를 가지고 있는 것</td>
    </tr>
    <tr>
      <td>필수적, 선택적 관계</td>
      <td>필수적 관계: 반드시 하나가 있어야 하는 관계<br />선택적 관계: 없을 수도 있는 관계</td>
    </tr>
  </tbody>
</table>

<h3 id="식별-관계와-비식별-관계">식별 관계와 비식별 관계</h3>

<p>식별 관계: 강한 개체의 기본키를 다른 엔터티의 기본키로 가지는 것</p>

<p>강한 개체(Strong Entity)</p>
<ul>
  <li>어떤 다른 엔터티에게 의존하지 않고 독립적으로 존재</li>
  <li>다른 엔터티와 관계를 가질 때 다른 엔터티에게 기본키를 공유함</li>
  <li>식별 관계로 표현</li>
  <li>기본키 값이 변경되면 식별 관계(기본키를 공유받은)에 있는 엔터티의 값도 변경</li>
  <li>강한 텐터티와 관계를 갖는 엔터티는 약한 개체(Weak Entity)가 됨</li>
</ul>

<p>비식별 관계: 강한 개체의 기본키를 다른 엔터티의 기본키가 아닌 일반 칼럼으로 관계를 가지는 것</p>

<h2 id="엔터티-식별자">엔터티 식별자</h2>
<hr />
<p>엔터티를 대표할 수 있는 유일성을 만족하는 속성</p>

<h3 id="키의-종류">키의 종류</h3>
<ul>
  <li>기본키(Primary key): 후보키 중에서 엔터티를 대표할 수 있는 키</li>
  <li>후보키(Candidate key): 유일성과 최소성을 만족하는 키</li>
  <li>슈퍼키(Super key): 유일성은 만족하지만 최소성을 만족하지 않는 키</li>
  <li>대체키(Alternate key): 여러 개의 후보키 중에서 기본키를 선정하고 남은 키</li>
  <li>외래키(Foreign key): 하나 혹은 다수의 다른 테이블의 기본 키 필드를 가리키는 것으로 참조 무결성을 확인하기 위해 사용되는 키</li>
</ul>

<h3 id="주식별자기본키-primary-key">주식별자(기본키, Primary key)</h3>
<ul>
  <li>최소성: 최소성을 만족하는 키</li>
  <li>대표성: 엔터티를 대표할 수 있어야 함</li>
  <li>유일성: 엔터티의 인스턴스를 유일하게 식별 가능</li>
  <li>불변성: 자주 변경되지 않아야 함</li>
</ul>

<h3 id="실별자의-종류">실별자의 종류</h3>
<p>식별자는 대표성, 생성 여부, 속성의 수, 대체 여부로 분류</p>

<h3 id="대표성-여부에-따른-식별자의-종류">대표성 여부에 따른 식별자의 종류</h3>
<ul>
  <li>주식별자: 유일성과 최소성을 만족하면서 엔터티를 대표하는 식별자로, 다른 엔터티와 참조 관계로 연결될 수 있음</li>
  <li>보조 식별자: 유일성과 최소성은 만족하지만 대표성을 만족하지 못하는 식별자</li>
</ul>

<h3 id="생성-여부에-따른-식별자의-종류">생성 여부에 따른 식별자의 종류</h3>
<ul>
  <li>내부 식별자: 엔터티 내부에서 스스로 생성되는 식별자</li>
  <li>외부 식별자: 다른 엔터티와의 관계로 인해 만들어지는 식별자</li>
</ul>

<h3 id="속성의-수에-따른-식별자의-종류">속성의 수에 따른 식별자의 종류</h3>
<ul>
  <li>단일 식별자: 하나의 속성으로 구성</li>
  <li>복합 식별자: 두 개 이상의 속성으로 구성</li>
</ul>

<h3 id="대체-여부에-따른-식별자의-종류">대체 여부에 따른 식별자의 종류</h3>
<ul>
  <li>본질 식별자: 비즈니스 프로세스에서 만들어지는 식별자</li>
  <li>인조 식별자: 인위적으로 만들어지는 식별자</li>
</ul>]]></content><author><name>Mindol</name></author><category term="Database" /><category term="Database" /><category term="study" /><summary type="html"><![CDATA[데이터 모델링 개념]]></summary></entry><entry><title type="html">QGIS3를 이용한 Shapefile 편집</title><link href="http://localhost:4000/qgis/2023/05/24/QGIS3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Shapefile-%ED%8E%B8%EC%A7%91.html" rel="alternate" type="text/html" title="QGIS3를 이용한 Shapefile 편집" /><published>2023-05-24T06:00:01+09:00</published><updated>2023-05-24T06:00:01+09:00</updated><id>http://localhost:4000/qgis/2023/05/24/QGIS3%EB%A5%BC%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20Shapefile%20%ED%8E%B8%EC%A7%91</id><content type="html" xml:base="http://localhost:4000/qgis/2023/05/24/QGIS3%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Shapefile-%ED%8E%B8%EC%A7%91.html"><![CDATA[<h2 id="tmi">TMI</h2>

<hr />

<p>해당 포스트는 국토지리정보원의 정밀 도로지도(NGII)를 예로 들고 있음.<br /><br />
<a href="https://hhh57463.github.io/qgis/2023/05/22/QGIS3-%EC%82%AC%EC%9A%A9%EB%B2%95.html">QGIS3 사용법</a></p>

<h2 id="shapefile-편집">Shapefile 편집</h2>

<hr />

<h3 id="편집모드">편집모드</h3>

<p>shapefile을 수정할 때는 항상 편집모드가 켜져야한다. 이는 QGIS3의 상단바에 <code class="language-plaintext highlighter-rouge">편집 모드 전환</code> 을 이용하여 켤 수 있다.</p>

<p><img src="/assets/img/QGIS3/edit_1.png" alt="Image" /></p>

<p>편집 모드를 켜면 특정 기능들을 사용할 수 있게 버튼들이 활성화 된다.</p>

<p><img src="/assets/img/QGIS3/edit_2.png" alt="Image" /></p>

<table>
  <thead>
    <tr>
      <th>아이콘</th>
      <th>기능</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/save.png" alt="Image" /></td>
      <td>레이어 편집 내용 저장</td>
      <td>해당 레이어에서 변경된 점을 저장한다.</td>
    </tr>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/add.png" alt="Image" /></td>
      <td>객체 추가</td>
      <td>해당 레이어에 맞는 Shape Type을 추가한다.</td>
    </tr>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/compass.png" alt="Image" /></td>
      <td>꼭짓점 도구</td>
      <td>현재 있는 객체의 꼭짓점을 기준으로 객체를 수정한다.</td>
    </tr>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/alledit.png" alt="Image" /></td>
      <td>선택한 모든 객체의 속성을 동시에 수정</td>
      <td>선택한 모든 객체를 동일한 값으로 수정할 수 있다.</td>
    </tr>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/delete.png" alt="Image" /></td>
      <td>선택 삭제</td>
      <td>선택한 객체를 제거한다.</td>
    </tr>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/cut.png" alt="Image" /></td>
      <td>잘라내기</td>
      <td>선택한 객체를 잘라낸다.</td>
    </tr>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/copy.png" alt="Image" /></td>
      <td>객체 복사</td>
      <td>선택한 객체를 복사한다.</td>
    </tr>
    <tr>
      <td><img src="/assets/img/QGIS3/Icon/paste.png" alt="Image" /></td>
      <td>객체 붙여넣기</td>
      <td>복사한 객체를 붙여넣는다.</td>
    </tr>
  </tbody>
</table>

<h2 id="데이터-수정">데이터 수정</h2>

<hr />

<h3 id="데이터-속성값-수정">데이터 속성값 수정</h3>

<p><code class="language-plaintext highlighter-rouge">이는 .shp를 수정하는 것이 아닌 .dbf의 요소를 수정하는 작업이다.</code></p>

<p>편집 모드가 켜진 상태에서 객체를 식별해준다.</p>

<p><img src="/assets/img/QGIS3/edit_3.png" alt="Image" /></p>

<p>식별 결과 탭에 상단에 있는 <code class="language-plaintext highlighter-rouge">객체 양식 편집</code> 버튼을 선택하여 객체 속성을 수정할 수 있다.</p>

<p><img src="/assets/img/QGIS3/edit_4.png" alt="Image" /></p>

<h2 id="shapefile-수정">Shapefile 수정</h2>

<hr />

<h3 id="데이터-수정-1">데이터 수정</h3>

<p>상단 바 중 <code class="language-plaintext highlighter-rouge">영역 또는 단일 클릭으로 객체 선택</code> 버튼을 선택한다.</p>

<p><img src="/assets/img/QGIS3/edit_5.png" alt="Image" /></p>

<p><img src="/assets/img/QGIS3/edit_6.png" alt="Image" /></p>

<p>해당 상태로 객체를 선택해주면 객체 위에 X표시가 나타난다</p>

<p>상단 탭의 <code class="language-plaintext highlighter-rouge">꼭짓점 도구</code> 를 선택하여 Drag &amp; Drop 하면 해당 꼭짓점의 객체를 이동시킬 수 있다.</p>

<p><img src="/assets/img/QGIS3/shapefile_edit_1.gif" alt="Image" /></p>

<p><code class="language-plaintext highlighter-rouge">Point형의 객체를 선택하면 해당 Point를 이동시킬 수 있다.</code></p>

<p>만약 PolyLine의 Point(지점)을 제거하고 싶다면 객체를 선택한 후 x표시가 나타난 상태에서 해당 객체를 우클릭하면 <code class="language-plaintext highlighter-rouge">꼭짓점 편집기</code> 가 켜진다.</p>

<p><img src="/assets/img/QGIS3/edit_7.png" alt="Image" /></p>

<p>꼭짓점 편집기에서 특정 튜플을 선택하면 객체에도 표시가 되는데 이 상태에서 <code class="language-plaintext highlighter-rouge">Delete</code> 키를 눌러주면 해당 꼭짓점을 삭제할 수 있다.</p>

<h3 id="데이터-삽입">데이터 삽입</h3>

<p>편집 모드 전환을 선택한 상태로 상단바의 <code class="language-plaintext highlighter-rouge">객체 추가</code> 버튼을 선택한다.</p>

<p><img src="/assets/img/QGIS3/shapefile_edit_2.gif" alt="Image" /></p>

<p>마우스 좌클릭으로 꼭짓점을 지정한 후 마우스 우클릭으로 완료해준다.</p>

<p><code class="language-plaintext highlighter-rouge">현재는 선택한 레이어가 PolyLine Type이기 때문에 꼭짓점을 지정해주어야 한다, 선택한 레이어가 Point Type일 시 Point의 위치를 지정해주면 된다.</code></p>

<p>.shp 데이터를 추가했으니 .dbf에 맞는 속성도 정의해 준 후 확인 버튼을 클릭하면 데이터가 추가된다.</p>

<p><img src="/assets/img/QGIS3/edit_8.png" alt="Image" /></p>

<p>해당 객체를 식별 해보면 입력한 속성 값이 들어간 것을 볼 수 있다.</p>

<h2 id="데이터-저장">데이터 저장</h2>

<hr />

<p>모든 편집이 종료되면 레이어 편집 내용 저장을 통해 변경된 내용을 저장해야 한다.</p>

<p><img src="/assets/img/QGIS3/edit_9.png" alt="Image" /></p>]]></content><author><name>Mindol</name></author><category term="QGIS" /><category term="QGIS" /><category term="shapefile" /><summary type="html"><![CDATA[Shapefile edit]]></summary></entry><entry><title type="html">QGIS3 사용법</title><link href="http://localhost:4000/qgis/2023/05/23/QGIS3-%EC%82%AC%EC%9A%A9%EB%B2%95.html" rel="alternate" type="text/html" title="QGIS3 사용법" /><published>2023-05-23T06:00:01+09:00</published><updated>2023-05-23T06:00:01+09:00</updated><id>http://localhost:4000/qgis/2023/05/23/QGIS3%20%EC%82%AC%EC%9A%A9%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/qgis/2023/05/23/QGIS3-%EC%82%AC%EC%9A%A9%EB%B2%95.html"><![CDATA[<h2 id="qgis란">QGIS란?</h2>

<hr />

<p>QGIS: 공간데이터 조회, 편집, 분석 기능을 제공하는 대표적인 오픈소스 데스크탑 지리정보시스템(GIS) 소프트웨어.</p>

<p><a href="[https://www.qgis.org/ko/site/](https://www.qgis.org/ko/site/)">설치링크</a></p>

<h2 id="tmi">TMI</h2>

<hr />

<p>해당 포스트는 국토지리정보원의 정밀 도로지도(NGII)를 예로 들고 있음.</p>

<h2 id="qgis3-사용법">QGIS3 사용법</h2>

<hr />

<h3 id="레이어-추가제거">레이어 추가/제거</h3>

<p>QGIS3를 실행하면 아래와 같은 화면이 시작된다.</p>

<p><img src="/assets/img/QGIS3/useage_1.png" alt="Image" /></p>

<p><img src="/assets/img/QGIS3/useage_2.png" alt="Image" /></p>

<p>QGIS3에 Shapefile(.shp)을 올리고 싶으면 좌하단 레이어 탭에 Shapefile을 Drag&amp;Drop한다.</p>

<p>특정 레이어를 제외하고 싶을 시 레이어 탭에서 해당 레이어의 이름 좌측 체크박스로 껏다 켤 수 있다.</p>

<p><img src="/assets/img/QGIS3/useage_3.png" alt="Image" /></p>

<p><code class="language-plaintext highlighter-rouge">A2_LINK의 체크박스 해제 후 모습</code></p>

<p><img src="/assets/img/QGIS3/useage_4.png" alt="Image" /></p>

<p>특정 레이어를 제거하고 싶을 시 레이어 선택 후 레이어 탭 중 상단 바에서 우측에 있는 <code class="language-plaintext highlighter-rouge">레이어/그룹 제거</code> 버튼을 클릭하거나, Ctrl + D를 사용하여 제거할 수 있다.</p>

<p>각 레이어의 심볼을 변경하고 싶을 경우 레이어 탭의 각 레이어를 더블클릭하여 수정할 수 있다.</p>

<p>변경할 수 있는 심볼은 각 레이어의 Shape Type에 맞는 심볼이 나온다.</p>

<p><img src="/assets/img/QGIS3/useage_5.png" alt="Image" /></p>

<p><code class="language-plaintext highlighter-rouge">Point Type의 Layer</code></p>

<p><img src="/assets/img/QGIS3/useage_6.png" alt="Image" /></p>

<p><code class="language-plaintext highlighter-rouge">PolyLine의 Layer</code></p>

<p>나는 각 레이어 식별을 쉽게하기 위해 색을 조정했다.</p>

<p><img src="/assets/img/QGIS3/useage_7.png" alt="Image" /></p>

<h3 id="데이터-조회">데이터 조회</h3>

<p>특정 데이터의 정보를 확인하기 위해서는 상단 바에서 객체 식별을 선택 후 확인해야한다.</p>

<p><img src="/assets/img/QGIS3/useage_8.png" alt="Image" /></p>

<p>‘A1_NODE’의 데이터를 확인하고 싶을 시, 레이어 탭에서 A1_NODE레이어를 선택 후 확인해야한다.</p>

<p><img src="/assets/img/QGIS3/useage_9.png" alt="Image" /></p>

<p>선택한 데이터는 식별 결과 탭에서 확인 가능하다.</p>

<p>특정 데이터의 속성을 검색하고 싶을 시 상단 바에서 <code class="language-plaintext highlighter-rouge">속성테이블 열기</code>를 클릭하거나 F6를 눌러 속성테이블을 켤 수 있다.</p>

<p><img src="/assets/img/QGIS3/useage_10.png" alt="Image" /></p>

<p><img src="/assets/img/QGIS3/useage_13.png" alt="Image" /></p>

<p>‘A1_NODE’의 속성 테이블</p>

<p><img src="/assets/img/QGIS3/useage_11.png" alt="Image" /></p>

<p>속성테이블의 상단 바에서 <code class="language-plaintext highlighter-rouge">서식을 이용해서 객체 선택/필터링</code> 을 선택하거나 Ctrl + F를 입력하여 검색란을 열 수 있다.</p>

<p><img src="/assets/img/QGIS3/useage_12.png" alt="Image" />
검색하려는 속성의 우측 <code class="language-plaintext highlighter-rouge">필드제외</code> 콤보박스를 클릭하면 검색 조건을 변경할 수 있다.</p>

<p>검색하려는 속성을 입력한 후 아래의 검색 방법 버튼을 클릭하여 특정 속성을 검색할 수 있다.</p>]]></content><author><name>Mindol</name></author><category term="QGIS" /><category term="QGIS" /><category term="shapefile" /><summary type="html"><![CDATA[QGIS3 useage]]></summary></entry><entry><title type="html">Shapefile Format</title><link href="http://localhost:4000/study/2023/05/19/%EA%B3%B5%EB%B6%80-Shapefile-Format.html" rel="alternate" type="text/html" title="Shapefile Format" /><published>2023-05-19T06:00:01+09:00</published><updated>2023-05-19T06:00:01+09:00</updated><id>http://localhost:4000/study/2023/05/19/%5B%EA%B3%B5%EB%B6%80%5DShapefile%20Format</id><content type="html" xml:base="http://localhost:4000/study/2023/05/19/%EA%B3%B5%EB%B6%80-Shapefile-Format.html"><![CDATA[<h1 id="tmi">TMI</h1>
<hr />
<p>교내 연구실에서 연구 진행 중 Shapefile format 분석을 의뢰받아 정리하여 요약</p>

<h2 id="목차">목차</h2>

<hr />

<ol>
  <li>shapefile이란?</li>
  <li>Little Endian, Big Endian</li>
  <li>shapefile 구성요소</li>
</ol>

<h2 id="shapefile이란">Shapefile이란?</h2>

<hr />

<p>.shp를 확장자로 가지며, 벡터방식으로 공간정보를 저장하는 파일.</p>

<p>shapefile은 점(Point), 선(Line), 면(Polygon) 중 하나의 속성을 가지며, shapefile에서 면(Polygon)을 잘라내거나 합칠 수 있다.</p>

<p>shapefile은 서로 다른 확장명을 가진 세 개 이상의 파일로 구성되는데</p>

<ul>
  <li>.shp - 피처의 지오메트리(형상)을 저장하는 기본파일</li>
  <li>.shx - 피처의 기하학의 색인을 저장하는 인덱스 파일</li>
  <li>.dbf - 피처의 속성 정보를 저장하는 dBASE 테이블</li>
</ul>

<p>이들을 구성 요소 파일이라 부른다.</p>

<p>위의 3개의 파일을 main file이라 칭하며 그 외에는 아래의 파일이 존재.</p>

<ul>
  <li>.prj - 지리 좌표를 알려주는 파일</li>
  <li>.sbn - 지리 공간 인덱스를 저장하는 파일</li>
  <li>.sbx - spatial join의 기능을 수행하거나 shape 필드에 대한 인덱스 생성에 필요한 파일</li>
</ul>

<p>*spatial join (공간결합): 두 공간 데이터프레임을 결합(merge)하는데, key 값이 아닌 위치정보에 따라 결합(overlay)해주는 방식.</p>

<h2 id="little-endian-big-endian">Little Endian, Big Endian</h2>

<hr />

<p>컴퓨터는 데이터를 메모리에 저장할 때 byte 단위로 나누어 저장하지만, 컴퓨터가 저장하는 데이터는 대게 32bit(4byte)나 64bit(8byte)로 구성된다.</p>

<p>따라서 연속되는 byte를 순서대로 저장해야 하는데, 이것을 바이트 저장 순서(byte order)라고 함.</p>

<p>바이트가 저장되는 순서에 따라 두 가지 방법으로 나눌 수 있다.</p>

<ul>
  <li>리틀 엔디안(Little Endian)</li>
  <li>빅 엔디안(Big Endian)</li>
</ul>

<h3 id="little-endian">Little Endian</h3>

<p>낮은 주소에 데이터의 낮은 바이트(LSB, Least Significant Bit)부터 저장하는 방식.</p>

<p>이 방식은 평소 우리가 숫자를 사용하는 선형 방식과는 반대로 거꾸로 읽어야 한다.</p>

<p>대부분 인텔 CPU 계열에서 이 방식으로 데이터를 저장함.</p>

<p>0x12345678을 저장해야 할 경우 이 정수는 0x12, 0x34, 0x56, 0x78로 1byte 값 4개로 구성됨.</p>

<p>이 4개의 1byte 값을 Big Endian 방식으로 저장되면 그림과 같이 저장됨.</p>

<p><img src="/assets/img/Shapefile/Shapefile_1.png" alt="리틀 엔디안 저장 방식" /></p>

<h3 id="big-endian">Big Endian</h3>

<p>낮은 주소에 데이터의 높은 바이트(MSB, Most Significant Bit)부터 저장하는 방식.</p>

<p>평소 우리가 숫자를 사용하는 선형 방식과 같은 방식.</p>

<p>메모리에 저장된 순서 그대로 읽을 수 있으며, 이해하기 쉽다는 장점을 가짐.</p>

<p>SPARC을 포함한 대부분의 RISC CPU 계열에서 이 방식으로 데이터를 저장함.</p>

<p>0x12345678을 저장해야 할 경우 이 정수는 0x12, 0x34, 0x56, 0x78로 1byte 값 4개로 구성됨.</p>

<p>이 4개의 1byte 값을 Big Endian 방식으로 저장되면 그림과 같이 저장됨.</p>

<p><img src="/assets/img/Shapefile/Shapefile_2.png" alt="빅 엔디안 저장 방식" /></p>

<h3 id="리틀-엔디안-vs-빅-엔디안">리틀 엔디안 vs 빅 엔디안</h3>

<p>빅 엔디안과 리틀 엔디안은 단지 저장해야 할 큰 데이터를 어떻게 나누어 저장하는가에 따른 차이일 뿐, 어느 방식이 더 우수하다고는 단정할 수 없음.</p>

<p>물리적으로 데이터를 조작하거나 산술 연산을 수행할 때에는 리틀 엔디안 방식이 더 효율적이지만,데이터의 각 바이트를 배열처럼 취급할 때에는 빅 엔디안 방식이 더 적합.</p>

<p>대부분의 시스템은 인텔 기반의 윈도우이므로 리틀 엔디안 방식을 사용.</p>

<p>네트워크를 통해 데이터를 전송할 때에는 빅 엔디안 방식이 사용.</p>

<p>인텔 기반의 시스템에서 소켓 통신을 할 때는 바이트 순서에 신경을 써서 데이터를 전달해야 함.</p>

<h2 id="shapefile-구성요소">Shapefile 구성요소</h2>

<hr />

<p>shapefile은 다음과 같이 구성됨.</p>

<p><img src="/assets/img/Shapefile/Shapefile_3.png" alt="Shapefile 구성요소" /></p>

<h3 id="file-header-구성">File Header 구성</h3>

<table>
  <thead>
    <tr>
      <th>Position</th>
      <th>Field</th>
      <th>Value</th>
      <th>Type</th>
      <th>Byte Order</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Byte 0</td>
      <td>File Code</td>
      <td>9994</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 4</td>
      <td>Unused</td>
      <td>0</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 8</td>
      <td>Unused</td>
      <td>0</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 12</td>
      <td>Unused</td>
      <td>0</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 16</td>
      <td>Unused</td>
      <td>0</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 20</td>
      <td>Unused</td>
      <td>0</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 24</td>
      <td>File Length</td>
      <td>File Length</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 28</td>
      <td>Version</td>
      <td>1000</td>
      <td>Integer</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 32</td>
      <td>Shape Type</td>
      <td>Shape Type</td>
      <td>Integer</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 36</td>
      <td>Bounding Box</td>
      <td>Xmin</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 44</td>
      <td>Bouding Box</td>
      <td>Ymin</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 52</td>
      <td>Bounding Box</td>
      <td>Xmax</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 60</td>
      <td>Bouding Box</td>
      <td>Ymax</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 68*</td>
      <td>Bounding Box</td>
      <td>Zmin</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 76*</td>
      <td>Bouding Box</td>
      <td>Zmax</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 84*</td>
      <td>Bounding Box</td>
      <td>Mmin</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 92*</td>
      <td>Bouding Box</td>
      <td>Mmax</td>
      <td>Double</td>
      <td>Little Endian</td>
    </tr>
  </tbody>
</table>

<p>Bounding Box란 해당 SHP 파일의 MBR(Minimum Bounding Rectangle)을 의미.</p>

<p>*MBR: 여러 점으로 구성되어 있을 경우 해당 점을 둘러싸고 있는 가장  작은 사각형으로, 해당 개체가 포함된 지도상의 위치를 대략적으로 표시하는 정보를 가짐.</p>

<h3 id="shape-type">Shape Type</h3>

<p>File Header구성 중 Byte32에 위치한 Shape Type은 이름당 값이 지정되어 있으며, 아래와 같다.</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NULL</td>
      <td>0</td>
    </tr>
    <tr>
      <td>POINT</td>
      <td>1</td>
    </tr>
    <tr>
      <td>ARC</td>
      <td>3</td>
    </tr>
    <tr>
      <td>POLYGON</td>
      <td>5</td>
    </tr>
    <tr>
      <td>MULTIPOINT</td>
      <td>8</td>
    </tr>
    <tr>
      <td>POINTZ</td>
      <td>11</td>
    </tr>
    <tr>
      <td>ARCZ</td>
      <td>13</td>
    </tr>
    <tr>
      <td>POLYGONZ</td>
      <td>15</td>
    </tr>
    <tr>
      <td>MULTIPOINTZ</td>
      <td>18</td>
    </tr>
    <tr>
      <td>POINTM</td>
      <td>21</td>
    </tr>
    <tr>
      <td>ARCM</td>
      <td>23</td>
    </tr>
    <tr>
      <td>POLYGONM</td>
      <td>25</td>
    </tr>
    <tr>
      <td>MULTIPOINTM</td>
      <td>28</td>
    </tr>
    <tr>
      <td>MULTIPATCH</td>
      <td>31</td>
    </tr>
  </tbody>
</table>

<p>SHP 포맷은 한 파일에 하나의 Shape Type만을 수용한다. 따라서 Point와 Line이 같은 파일에 있을 수 없다.</p>

<h3 id="record-header">Record Header</h3>

<table>
  <thead>
    <tr>
      <th>Position</th>
      <th>Field</th>
      <th>Value</th>
      <th>Type</th>
      <th>Order</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Byte 0</td>
      <td>Record Number</td>
      <td>Record Number</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
    <tr>
      <td>Byte 4</td>
      <td>Content Length</td>
      <td>Content Length</td>
      <td>Integer</td>
      <td>Big Endian</td>
    </tr>
  </tbody>
</table>

<p>Record Header는 거의 사용되지 않음.(.shx 파일을 이용해 shp를 포인팅할 수 있기 때문)</p>

<h3 id="record-contents">Record Contents</h3>

<p>Record Contents는 실제 점(Point), 선(Line), 면(Polygon)이 기록되어 있으며, Shape Type에 따라 달라짐.</p>

<p>ShapeType - Point</p>

<table>
  <thead>
    <tr>
      <th>Position</th>
      <th>Field</th>
      <th>Value</th>
      <th>Type</th>
      <th>Number</th>
      <th>Order</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Byte 0</td>
      <td>Shape Type</td>
      <td>1</td>
      <td>Integer</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 4</td>
      <td>X</td>
      <td>X</td>
      <td>Double</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 12</td>
      <td>Y</td>
      <td>Y</td>
      <td>Double</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
  </tbody>
</table>

<p>Point는 double로 된 x, y로 구성되어 있는 값.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Point</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ShapeType - Multi Point</p>

<p>Multi Point(다중 포인트)는 여러 개의 점을 하나의 개체로 인식하는 것. 위치가 다른 곳에 있는 점이라도 같은 속성을 지니고 있을 경우 이들을 하나로 묶어서 사용하기 좋음</p>

<table>
  <thead>
    <tr>
      <th>Position</th>
      <th>Field</th>
      <th>Value</th>
      <th>Type</th>
      <th>Number</th>
      <th>Order</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Byte 0</td>
      <td>Shape Type</td>
      <td>8</td>
      <td>Integer</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 4</td>
      <td>Box</td>
      <td>Box</td>
      <td>Double</td>
      <td>4</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 36</td>
      <td>NumPoints</td>
      <td>NumPoints</td>
      <td>Integer</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 40</td>
      <td>Points</td>
      <td>Points</td>
      <td>Point</td>
      <td>NumPoints</td>
      <td>Little Endian</td>
    </tr>
  </tbody>
</table>

<p>Byte 4에 위치한 Box 또한 MBR.</p>

<p>Byte 36의 NumPoints는 개체가 가지는 점(Point)의 개수를 나타내며, Multi Point는 여러 개의 점을 하나의 개체로 묶은 것이기 때문에, 개체당 점이 하나 이상 존재할 수 있음.</p>

<p>Byte 40부터는 개체 내에 실제로 포함된 점(Point)들을 담고 있는 것으로, 개체당 하나 이상의 점이 존재할 수 있으므로, NumPoints만큼의 Point가 나열됨.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">MultiPoint</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">Box</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">NumPoints</span><span class="p">;</span>
  <span class="n">Point</span><span class="p">[</span><span class="n">NumPoints</span><span class="p">]</span> <span class="n">Points</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ShapeType - PolyLine, Arc</p>

<p>아크는 Line 혹은 PolyLine을 수용하는 구조체로, 다중 포인트처럼 위치가 다른 곳에 있는 선을 같은 개체로 처리할 수 있음.</p>

<table>
  <thead>
    <tr>
      <th>Position</th>
      <th>Field</th>
      <th>Value</th>
      <th>Type</th>
      <th>Number</th>
      <th>Order</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Byte 0</td>
      <td>Shape Type</td>
      <td>3</td>
      <td>Integer</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 4</td>
      <td>Box</td>
      <td>Box</td>
      <td>Double</td>
      <td>4</td>
      <td>Litle Endian</td>
    </tr>
    <tr>
      <td>Byte 36</td>
      <td>NumParts</td>
      <td>NumParts</td>
      <td>Integer</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 40</td>
      <td>NumPoints</td>
      <td>NumPoints</td>
      <td>Integer</td>
      <td>1</td>
      <td>Litle Endian</td>
    </tr>
    <tr>
      <td>Byte 44</td>
      <td>Parts</td>
      <td>Parts</td>
      <td>Integer</td>
      <td>NumParts</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte X</td>
      <td>Points</td>
      <td>Points</td>
      <td>Point</td>
      <td>NumParts</td>
      <td>Litle Endian</td>
    </tr>
  </tbody>
</table>

<p>*Part: 한 Arc 개체에 몇 개의 PolyLine이 존재하는지</p>

<p>Byte 4의 Box 역시 MBR을 의미</p>

<p>Byte 36의 NumParts는 Arc 개체에 속한 PolyLine 개체의 수를 나타내며, Byte 40의 NumPoints는 해당 Arc 개체에 포함된 전체 점의 수를 의미.</p>

<p>Byte 40의 NumPoints는 개체에 있는 점의 수를 의미, 위치나 Part와 관계없이 저장되며 점의 개수가 몇 개인지 지정하는 것.</p>

<p>Byte 44의 Parts는 각각의 PolyLine 개체가 몇 개의 점으로 이루어져 있는지를 나타내며, 이를 통해 어느 부분이 어떤 PolyLine에 속하는지를 파악할 수 있음.</p>

<p>Byte X의 Points는 각 점의 위치를 나타내며, PolyLine 개체의 경우는 순서대로 각 점의 위치가 저장되며, Arc 개체의 경우는 여러 개의 PolyLine으로 이루어져 있으므로 Parts 정보를 통해 어느 PolyLine에 속하는지를 파악한 후 해당 PolyLine에 속한 각 점의 위치가 순서대로 저장됨.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">PolyLine</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">Box</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">NumParts</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">NumPoints</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">Parts</span><span class="p">[</span><span class="n">NumParts</span><span class="p">];</span>
  <span class="n">Point</span><span class="p">[</span><span class="n">NumPoints</span><span class="p">]</span> <span class="n">Points</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ShapeType - Polygon</p>

<p>Polygon은 PolyLine 혹은 Arc의 구조와 같지만 파트별로 시작점과 끝점이 같아서 닫혀있다는 것을 강조.</p>

<table>
  <thead>
    <tr>
      <th>Position</th>
      <th>Field</th>
      <th>Value</th>
      <th>Type</th>
      <th>Number</th>
      <th>Order</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Byte 0</td>
      <td>Shape Type</td>
      <td>5</td>
      <td>Integer</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 4</td>
      <td>Box</td>
      <td>Box</td>
      <td>Double</td>
      <td>4</td>
      <td>Litle Endian</td>
    </tr>
    <tr>
      <td>Byte 36</td>
      <td>NumParts</td>
      <td>NumParts</td>
      <td>Integer</td>
      <td>1</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte 40</td>
      <td>NumPoints</td>
      <td>NumPoints</td>
      <td>Integer</td>
      <td>1</td>
      <td>Litle Endian</td>
    </tr>
    <tr>
      <td>Byte 44</td>
      <td>Parts</td>
      <td>Parts</td>
      <td>Integer</td>
      <td>NumParts</td>
      <td>Little Endian</td>
    </tr>
    <tr>
      <td>Byte X</td>
      <td>Points</td>
      <td>Points</td>
      <td>Point</td>
      <td>NumParts</td>
      <td>Litle Endian</td>
    </tr>
  </tbody>
</table>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Polygon</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">Box</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">NumParts</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">NumPoints</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">Parts</span><span class="p">[</span><span class="n">NumParts</span><span class="p">];</span>
  <span class="n">Point</span><span class="p">[</span><span class="n">NumPoints</span><span class="p">]</span> <span class="n">Points</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="출처-및-참고">출처 및 참고</h3>
<hr />
<p><a href="https://yganalyst.github.io/spatial_analysis/spatial_analysis_4/">[GIS] 공간 데이터 결합(Spatial Join)</a></p>

<p><a href="http://www.tcpschool.com/c/c_refer_endian">코딩교육 티씨피스쿨</a></p>

<p><a href="https://velog.io/@cha-suyeon/QGIS-알아가기-shapefile이란-무엇일까.shp">QGIS 알아가기 - shapefile이란 무엇일까?(.shp)</a></p>

<p><a href="https://endofcap.tistory.com/3">[SHPViewer 강좌 1] SHP 포맷 분석 1</a></p>

<p><a href="https://docs.fileformat.com/gis/shp/">SHP - ESRI Shapefile</a></p>]]></content><author><name>Mindol</name></author><category term="Study" /><category term="study" /><category term="shapefile" /><summary type="html"><![CDATA[shapefile format]]></summary></entry><entry><title type="html">JsonUtility</title><link href="http://localhost:4000/unity/2023/04/03/JsonUtility.html" rel="alternate" type="text/html" title="JsonUtility" /><published>2023-04-03T06:00:01+09:00</published><updated>2023-04-03T06:00:01+09:00</updated><id>http://localhost:4000/unity/2023/04/03/JsonUtility</id><content type="html" xml:base="http://localhost:4000/unity/2023/04/03/JsonUtility.html"><![CDATA[<p>최근 RPG제작에 용이한 기능들을 제작하는 프로젝트 <a href="https://github.com/hhh57463/RPG_Helper">RPG_Helper</a>를 제작하던 중 인벤토리 구현에 필요한 DB연동 대신 JSON을 활용하던 중 알게된 부분을 정리한다.</p>

<h2 id="json">JSON?</h2>
<hr />
<p>JavaScript Object Notaion의 약자로 직역하자면 자바 스크립트 객체 표기법으로 데이터를 쉽게 교환 및 저장하기 위한 텍스트 기반의 데이터 교환 표준이다.<br /><br /></p>

<h3 id="json-구조">JSON 구조</h3>
<p>자료형: string, number, true, false, null, object, array<br />
기본적으로 <code class="language-plaintext highlighter-rouge">key: value</code> 형태의 구조를 가지며, <code class="language-plaintext highlighter-rouge">중괄호 {}</code>로 감싸게 됨<br />
key 값은 문자열로 이루어져야하며, value에는 지원되는 자료형으로 이루어지면 된다<br /><br /></p>

<pre><code class="language-JSON">{

    "나이" : 25,                      // number
    "이름" : "Mindol",                // string
    "취미" : ["영화감상", "노래방"]   // array
}
</code></pre>

<h3 id="json-장단점">JSON 장단점</h3>
<ul>
  <li>텍스트 기반으로 다양한 프로그래밍 언어에서 데이터를 읽고 사용이 가능</li>
  <li>내용이 함축적으로 최소한의 정보만을 가짐</li>
  <li>내용이 함축적이다 보니 의미 파악이 힘들 수 있음</li>
</ul>

<h2 id="jsonutility">JsonUtility</h2>
<hr />
<p>Unity에서 지원하는 JSON 데이터 작업을 위한 유틸리티 함수로, 데이터를 JSON형태로 저장 및 읽어올 수 있다.</p>

<h2 id="example">Example</h2>
<hr />
<p>만약 게임이 종료될 때 플레이어의 위치를 저장하고 게임을 재시작하면 저장된 위치를 불러와야하는 기능을 구현하려면 어떻게 해야할까?</p>

<h2 id="json-export">JSON export</h2>
<hr />
<p>우선 2D환경에서 CharactorController를 이용한 간단한 이동을 구현했다.</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">h</span> <span class="p">=&gt;</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">v</span> <span class="p">=&gt;</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Vertical"</span><span class="p">);</span>
<span class="k">void</span> <span class="nf">Move</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Vector2</span> <span class="n">movement</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="n">movement</span> <span class="p">*=</span> <span class="p">(</span><span class="n">moveSpeed</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">);</span>
    <span class="n">controller</span><span class="p">.</span><span class="nf">Move</span><span class="p">(</span><span class="n">movement</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>게임이 종료될 때 위치를 저장해야하니 OnApplicationQuit함수를 이용했다.<br /></p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">OnApplicationQuit</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Vector2</span> <span class="n">savePos</span> <span class="p">=</span> <span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
    <span class="kt">string</span> <span class="n">path</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">IO</span><span class="p">.</span><span class="n">Path</span><span class="p">.</span><span class="nf">Combine</span><span class="p">(</span><span class="n">Application</span><span class="p">.</span><span class="n">dataPath</span> <span class="p">+</span>
                                        <span class="s">"/Json/"</span><span class="p">,</span> <span class="s">"playerdata.json"</span><span class="p">);</span>
    <span class="n">System</span><span class="p">.</span><span class="n">IO</span><span class="p">.</span><span class="n">File</span><span class="p">.</span><span class="nf">WriteAllText</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">JsonUtility</span><span class="p">.</span><span class="nf">ToJson</span><span class="p">(</span><span class="n">savePos</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="코드해석">코드해석</h3>
<p>Vector2 savePos: 플레이어의 월드좌표를 저장하는 변수<br /><br />
string path: JSON파일을 생성할 위치지정 Application.dataPath를 이용하여 현재 프로젝트 Assets폴더에 접근 가능하다. 최종적으로 <code class="language-plaintext highlighter-rouge">Assets/Json/playerdata.json</code>이라는 경로가 지정된다.<br /><br />
JsonUtility.ToJson(savePos): JsonUtility.ToJson함수를 이용하여 객체를 JSON문법으로 변환하여 WriteAllText함수로 지정된 경로에 저장하였다.</p>

<h3 id="jsonutilitytojson">JsonUtility.ToJson</h3>
<p>매개변수로 들어온 객체를 JSON문법으로 변환해준다. Debug.Log함수를 이용하여 확인해보면<br />
<img src="/assets/img/Unity/JsonUtility_1.png" alt="image" /><br />
Vector2형식을 JSON형식으로 변환한 것을 볼 수 있다.</p>

<h2 id="json-import">JSON import</h2>
<hr />
<p>이제 반대로 JSON파일에서 불러오는 작업을 수행해야하는데, JSON파일을 읽어오는 함수 LoadJson을 만들어준 후 플레이어 객체가 생성될 때 호출해야하므로 Start함수에서 호출해줬다.</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">LoadJson</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="n">loadData</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">IO</span><span class="p">.</span><span class="n">File</span><span class="p">.</span><span class="nf">ReadAllText</span><span class="p">(</span>
                        <span class="n">System</span><span class="p">.</span><span class="n">IO</span><span class="p">.</span><span class="n">Path</span><span class="p">.</span><span class="nf">Combine</span><span class="p">(</span><span class="n">Application</span><span class="p">.</span><span class="n">dataPath</span> <span class="p">+</span> 
                        <span class="s">"/Json/"</span><span class="p">,</span> <span class="s">"playerdata.json"</span><span class="p">));</span>
    <span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">=</span> <span class="n">JsonUtility</span><span class="p">.</span><span class="n">FromJson</span><span class="p">&lt;</span><span class="n">Vector2</span><span class="p">&gt;(</span><span class="n">loadData</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="코드해석-1">코드해석</h3>
<p>string loadData: playerdata.json을 ReadAllText함수를 이용하여 문자열로 저장해준다.<br /><br />
JsonUtility.FromJson<Vector2>(loadData): 읽어온 JSON 데이터를 Vector2자료형으로 반환한다.<br /><br /></Vector2></p>

<h3 id="jsonutilityfromjson">JsonUtility.FromJson</h3>
<p>매개변수로 읽어온 JSON데이터(문자열)를 지정한 자료형으로 변환하여 반환한다.<br />
<code class="language-plaintext highlighter-rouge">JsonUtility.FromJson&lt;자료형&gt;(문자열);</code></p>

<h3 id="결과">결과</h3>
<hr />
<p><img src="/assets/img/Unity/JsonUtility_2.gif" alt="image" /><br />
실행하여 플레이어를 이동시킨 후 재시작하면 종료했던 위치로 플레이어가 이동하는 것을 볼 수 있다.<br /></p>

<h3 id="여러-데이터-json화-시키기">여러 데이터 JSON화 시키기</h3>
<hr />
<p>만약 플레이어의 위치 뿐만 아닌 여러 데이터를 JSON에 저장해야할 경우에는 배열로 저장하여 JSON에 저장해야한다.<br /></p>

<p><a href="https://github.com/hhh57463/RPG_Helper">RPG_Helper</a> 제작 중 획득한 아이템 리스트를 JSON에 저장하였는데 아이템의 종류는 장착, 소비, 기타 이렇게 3개의 종류가 있다. 해당 아이템들을 각각의 리스트로 구현하였는데 이를 각자 다른 데이터로 저장해주었다.</p>

<p>아래는 JSON파일에 들어갈 아이템의 구성 요소이다.</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">System</span><span class="p">.</span><span class="n">Serializable</span><span class="p">]</span>           <span class="c1">// 직렬화</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ItemsData</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">name</span><span class="p">;</span>         <span class="c1">// 아이템 이름</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">info</span><span class="p">;</span>         <span class="c1">// 아이템 정보</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>           <span class="c1">// 아이템 갯수</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">link</span><span class="p">;</span>         <span class="c1">// 아이템 이미지 링크</span>

    <span class="c1">// 새로운 아이템을 획득할 때 사용하는 생성자</span>
    <span class="k">public</span> <span class="nf">ItemsData</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">string</span> <span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">string</span> <span class="n">link</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">name</span> <span class="p">=</span> <span class="n">name</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">info</span> <span class="p">=</span> <span class="n">info</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">count</span> <span class="p">=</span> <span class="n">count</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">link</span> <span class="p">=</span> <span class="n">link</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>아래는 아이템을 관리할 ItemDataMng클래스의 구성 요소이다.</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">System</span><span class="p">.</span><span class="n">Serializable</span><span class="p">]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">ItemDataMng</span>
<span class="p">{</span>
    <span class="c1">// 장착 아이템</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemsData</span><span class="p">&gt;</span> <span class="n">equipItem</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemsData</span><span class="p">&gt;();</span>
    <span class="c1">// 소비 아이템     </span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemsData</span><span class="p">&gt;</span> <span class="n">consumItem</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemsData</span><span class="p">&gt;();</span>
    <span class="c1">// 기타 아이템</span>
    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemsData</span><span class="p">&gt;</span> <span class="n">etcItem</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ItemsData</span><span class="p">&gt;();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>아래는 JSON 데이터를 변환하여 저장하는 소스코드들이다.</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TextAsset</span> <span class="n">itemJson</span><span class="p">;</span>        <span class="c1">// JSON 데이터 파일</span>
<span class="n">ItemDataMng</span> <span class="n">itemDatas</span><span class="p">;</span>     <span class="c1">// 아이템을 관리할 변수(인벤토리)</span>
<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// JSON파일을 읽어와 인벤토리에 데이터 저장</span>
    <span class="n">itemDatas</span> <span class="p">=</span> <span class="n">JsonUtility</span><span class="p">.</span><span class="n">FromJson</span><span class="p">&lt;</span><span class="n">ItemDataMng</span><span class="p">&gt;(</span><span class="n">itemJson</span><span class="p">.</span><span class="n">text</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 게임 종료시 가지고 있는 아이템 저장</span>
<span class="k">void</span> <span class="nf">OnApplicationQuit</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="n">saveData</span> <span class="p">=</span> <span class="n">JsonUtility</span><span class="p">.</span><span class="nf">ToJson</span><span class="p">(</span><span class="n">itemDatas</span><span class="p">);</span>
    <span class="kt">string</span> <span class="n">fileName</span> <span class="p">=</span> <span class="s">"ItemData.json"</span><span class="p">;</span>
    <span class="kt">string</span> <span class="n">path</span> <span class="p">=</span> <span class="n">Application</span><span class="p">.</span><span class="n">dataPath</span> <span class="p">+</span> <span class="s">"/Inventory/Json/"</span> <span class="p">+</span> <span class="n">fileName</span><span class="p">;</span>
    <span class="n">System</span><span class="p">.</span><span class="n">IO</span><span class="p">.</span><span class="n">File</span><span class="p">.</span><span class="nf">WriteAllText</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">saveData</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="결과-json-파일">결과 (JSON 파일)</h2>
<hr />
<p><img src="/assets/img/Unity/JsonUtility_3.png" alt="image" /><br />
여러 데이터가 JSON 파일에 저장되는 것을 볼 수 있으며,<br /><br />
<img src="/assets/img/Unity/JsonUtility_4.gif" alt="image" /><br />
각각의 데이터에 맞는 요소들이 인벤토리에 저장되는 것을 볼 수 있다.(이미지 로드가 늦는 이유는 인터넷에서 받아오기에 속도차이가 있다.)</p>

<h2 id="주의점">주의점</h2>
<hr />
<p>만약 JSON파일에서 내용을 읽어와 클래스나 구조체에 저장한다면 JSON의 이름과 해당 데이터를 저장하는 변수의 이름을 같게 지정해줘야한다.<br /><br />
해당 포스팅의 내용을 보면 아이템의 종류를 나타내는 <code class="language-plaintext highlighter-rouge">equipItem, cousumItem, etcItem</code>이 JSON 내부의 데이터 이름과 같을걸 볼 수 있다.<br /><br />
만약 서로 이름이 다르면 아래처럼 데이터가 잘 불러와지지 않거나, 에러가 발생한다.<br />
<img src="/assets/img/Unity/JsonUtility_5.png" alt="image" /><br /></p>]]></content><author><name>Mindol</name></author><category term="Unity" /><category term="unity" /><category term="study" /><summary type="html"><![CDATA[JsonUtility를 이용한 JSON 파싱]]></summary></entry><entry><title type="html">[Flutter] - VSCode 편의기능</title><link href="http://localhost:4000/flutter/2023/02/22/Flutter-VSCode-%EA%B8%B0%EB%8A%A5.html" rel="alternate" type="text/html" title="[Flutter] - VSCode 편의기능" /><published>2023-02-22T06:00:02+09:00</published><updated>2023-02-22T06:00:02+09:00</updated><id>http://localhost:4000/flutter/2023/02/22/Flutter%20VSCode%20%EA%B8%B0%EB%8A%A5</id><content type="html" xml:base="http://localhost:4000/flutter/2023/02/22/Flutter-VSCode-%EA%B8%B0%EB%8A%A5.html"><![CDATA[<h2 id="editorcodeactionsonsave">editor.codeActionsOnSave</h2>
<hr />
<p><img src="/assets/img/Flutter/flutter_craft_1.png" alt="image" width="50%" height="50%" /><br />
VSCode로 Flutter를 하다보면 코드 아래 밑줄이 생기는 것을 볼 수 있다<br /><br />
<img src="/assets/img/Flutter/flutter_craft_2.png" alt="image" /><br />
커서를 올려보면 바뀌지 않는 값을 const로 지정해 주라는 뜻이다<br /><br />
<img src="/assets/img/Flutter/flutter_craft_3.png" alt="image" width="50%" height="50%" /><br />
VSCode좌하단 설정버튼→명령 팔레트 클릭 또는 <code class="language-plaintext highlighter-rouge">Ctrl + Shift + P</code> 후<br /><br />
<img src="/assets/img/Flutter/flutter_craft_4.png" alt="image" /><br />
<code class="language-plaintext highlighter-rouge">open user Settings</code>를 입력하면<br /><br />
<img src="/assets/img/Flutter/flutter_craft_5.png" alt="image" /><br />
settings.json 파일이 열린다<br /><br />
<img src="/assets/img/Flutter/flutter_craft_6.png" alt="image" /><br />
하단에 <code class="language-plaintext highlighter-rouge">"editor.codeActionsOnSave": {"source.fixAll": true},</code>를 입력해준다<br /><br />
이제 코드 작업을 수행한 후 저장하면 밑줄이 생기던 코드가 자동으로 수정된다.</p>

<h2 id="dartpreviewflutteruiguides">dart.previewFlutterUiGuides</h2>
<hr />
<p><img src="/assets/img/Flutter/flutter_craft_7.png" alt="image" /><br />
위젯의 부모가 무엇인지 가이드라인을 시각적으로 보여주는 기능<br /><br />
<img src="/assets/img/Flutter/flutter_craft_8.png" alt="image" /><br />
settings.json파일 하단에 <code class="language-plaintext highlighter-rouge">"dart.previewFlutterUiGuides": true,</code> 를 입력후 저장하고 VSCode를 껏다 켜주면 적용된다.</p>

<h2 id="code-actions">Code Actions</h2>
<hr />
<p>Code Actions: 코드를 간단한 방법으로 리팩토링 해주는 기능
<img src="/assets/img/Flutter/flutter_craft_9.png" alt="image" width="50%" height="50%" /><br />
만약 해당 Column을 Padding으로 감싸고 싶으면 Column을 클릭 후 왼쪽 노란 전구를 클릭해준다.<br /><br />
<img src="/assets/img/Flutter/flutter_craft_10.png" alt="image" width="50%" height="50%" /><br />
Wrap with Padding을 클릭해주면 <br /><br />
<img src="/assets/img/Flutter/flutter_craft_11.png" alt="image" width="50%" height="50%" /><br />
원래라면 복사 붙여넣기 해서 Padding을 추가했다면 클릭 한번으로 Padding으로 감쌀 수 있다.<br /><br />
<img src="/assets/img/Flutter/flutter_craft_12.png" alt="image" width="50%" height="50%" /><br />
Remove this widget을 클릭하면<br /><br />
<img src="/assets/img/Flutter/flutter_craft_13.png" alt="image" width="50%" height="50%" /><br />
해당 위젯이 사라지는것을 볼 수 있다.</p>]]></content><author><name>Mindol</name></author><category term="Flutter" /><category term="Flutter" /><category term="Dart" /><summary type="html"><![CDATA[코드 자동 수정, 가이드라인, 리팩토링]]></summary></entry><entry><title type="html">URP</title><link href="http://localhost:4000/unity/2023/02/08/URP.html" rel="alternate" type="text/html" title="URP" /><published>2023-02-08T07:00:00+09:00</published><updated>2023-02-08T07:00:00+09:00</updated><id>http://localhost:4000/unity/2023/02/08/URP</id><content type="html" xml:base="http://localhost:4000/unity/2023/02/08/URP.html"><![CDATA[<h2 id="urp">URP?</h2>
<hr />
<p>항상 유니티 vs 언리얼에서 유니티가 무시받던 것이 바로 그래픽 능력. 유니티에서 새로운 파이프라인을 만들어 제공했는데 기존에는 디폴트 파이프라인이었지만, 설정을 통해 새로운 파이프라인을 사용할 수 있다.<br /><br />
Universal Render Pipeline (URP): Unity에서 제작한 사전 빌드된 스크립터블 렌더 파이프라인<br /><br />
URP는 아티스트 친화적 워크플로를 통해 모바일, 고사양 콘솔, PC 등 다양한 플랫폼에서 최적화된 그래픽스를 쉽고 빠르게 구현하도록 도와준다.</p>

<h2 id="urp-설정">URP 설정</h2>
<hr />
<p><img src="/assets/img/Unity/URP_1.png" alt="image" /><br />
Window→Package Manager<br /><br />
<img src="/assets/img/Unity/URP_2.png" alt="image" /><br />
Packages를 Unity Registry로 변경 후 Universal RP를 찾아 install<br /><br />
<img src="/assets/img/Unity/URP_3.png" alt="image" /><br />
Packages 디렉터리에 Universal RP가 생긴것을 볼 수 있다<br /><br />
Render Pipeline을 기존 디폴트에서 URP로 변경해줘야한다.<br /><br />
<img src="/assets/img/Unity/URP_4.png" alt="image" /><br />
Create→Rendering→URP Asset (with Universal Renderer)<br /><br />
<img src="/assets/img/Unity/URP_5.png" alt="image" /><br />
두개의 파일이 생성된다.<br /><br />
두 파일 중 Universal Render Pipeline Asset을 적용시켜줘야한다.<br /><br />
<img src="/assets/img/Unity/URP_6.png" alt="image" /><br />
Project Settings→Graphics→Scriptable Render Pipeline Settings에 Universal Render Pipeline Asset을 연결해준다.</p>

<h2 id="material">Material</h2>
<hr />
<p><img src="/assets/img/Unity/URP_7.png" alt="image" /><br />
Material의 Shader가 Universal Render Pipeline/Lit으로 설정되어있다.<br /><br />
파이프라인이 변경되어 셰이더를 URP에 있는 것들만 사용해야 한다.</p>

<h2 id="shader">Shader</h2>
<hr />

<table>
  <thead>
    <tr>
      <th>셰이더</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2D</td>
      <td>2D 프로젝트 개발시 사용</td>
    </tr>
    <tr>
      <td>Autodesk Interactive</td>
      <td>AutoDesk 응용 프로그램과 조정할 때 사용</td>
    </tr>
    <tr>
      <td>Nature</td>
      <td>Speed Tree에 특화된 셰이더 포함</td>
    </tr>
    <tr>
      <td>Particle</td>
      <td>이펙트 제작에 사용 (파티클 시스템)</td>
    </tr>
    <tr>
      <td>Baked Lit</td>
      <td>라이트 맵과 라이트 프로브를 통해 베이크된 조명만 필요한 스타일화 된 게임이나 앱에 사용<br /><br />물리적 기반 셰이딩을 사용하지 않으며 실시간 조명이 없어 실시관 관련 셰이더 키워브 및 변형이 셰이더 코드에서 제거되어 계산 속도가 빠르다<br /><br />미리 라이트 관련된 것들을 실시간으로 계산하지 않을때 사용</td>
    </tr>
    <tr>
      <td>Lit</td>
      <td>실제 표면을 사실적인 품질로 렌더링 시켜줌. 무거우며 디폴트로 설정되어있음</td>
    </tr>
    <tr>
      <td>Simple Lit</td>
      <td>성능이 좋지만 리얼한 셰이더 느낌이 아님, Lit을 사용하기엔 무겁고 Baked Lit을 할 줄 모른다면 사용</td>
    </tr>
    <tr>
      <td>Unlit</td>
      <td>전역 조명을 샘플링하는 옵션이 있는 조명없는 셰이더, Unity의 스톡 언릿 셰이더 대체</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Mindol</name></author><category term="Unity" /><category term="unity" /><category term="study" /><summary type="html"><![CDATA[Unity URP]]></summary></entry><entry><title type="html">Cinemachine</title><link href="http://localhost:4000/unity/2023/02/07/Cinemachine.html" rel="alternate" type="text/html" title="Cinemachine" /><published>2023-02-07T06:00:01+09:00</published><updated>2023-02-07T06:00:01+09:00</updated><id>http://localhost:4000/unity/2023/02/07/Cinemachine</id><content type="html" xml:base="http://localhost:4000/unity/2023/02/07/Cinemachine.html"><![CDATA[<h2 id="시네머신">시네머신?</h2>
<hr />
<p>영화 촬영을 하는 것처럼 씬을 촬영하여 게임 화면상에 비추어주는 유니티 패키지.<br /><br />
기본적으로 카메라 오브젝트를 생성하지 않고 가상 카메라를 이용.<br /><br />
가상 카메라는 원래 있는 카메라 오브젝트를 이용하여 여러 환경에서 비추어줄 씬을 보여주도록 도와줌.<br /><br />
가상 카메라는 서로에게 영향을 끼치지 않으며, 유니티 카메라에도 영향을 받지 않아 자유로운 카메라 구성이 가능.</p>

<h2 id="패키지-추가">패키지 추가</h2>
<hr />

<p><img src="/assets/img/Unity/Cinemachine_1.png" alt="image" /><br />
Window→Package Manager<br /><br />
<img src="/assets/img/Unity/Cinemachine_2.png" alt="image" /><br />
Packages를 Unity Registry로 변경 후 Cinemachine을 찾아 install<br /><br />
<img src="/assets/img/Unity/Cinemachine_3.png" alt="image" /><br />
Packages 디렉터리에 Cinemachine이 생긴것을 볼 수 있다<br /><br />
<img src="/assets/img/Unity/Cinemachine_4.png" alt="image" /><br />
Hierachy에서 시네머신 카메라를 생성할 수 있다.<br /><br /></p>

<h2 id="종류">종류</h2>
<hr />

<table>
  <thead>
    <tr>
      <th>카메라</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Virtual Camera</td>
      <td>기본적인 카메라, 유니티 카메라를 조정하듯 자유롭게 활용 가능</td>
    </tr>
    <tr>
      <td>FreeLook Camera</td>
      <td>오브젝트를 중심으로 원형의 링을 생성하여 그 구간 안에서 타깃을 관찰하는 카메라</td>
    </tr>
    <tr>
      <td>Blend List Camera</td>
      <td>할당된 버추얼 카메라들을 정해진 블랜드 방식에 따라 순차적으로 전환하는 카메라</td>
    </tr>
    <tr>
      <td>State-Driven Camera</td>
      <td>타겟 애니메이션의 상태별로 활성화/비활성화 시킬 수 있는 카메라</td>
    </tr>
    <tr>
      <td>ClearShot Camera</td>
      <td>플레이어의 충돌/트리거 상태에 따라 활성화/비활성화 시킬 수 있는 카메라</td>
    </tr>
    <tr>
      <td>Dolly Camera</td>
      <td>트랙을 깔아 해당 트랙에 따라 움직이는 카메라, Dolly Track과 함께 사용</td>
    </tr>
    <tr>
      <td>Target Group Camera</td>
      <td>그룹으로 묶인 카메라들을 자동으로 계산해 한 화면에 보여주는 카메라</td>
    </tr>
    <tr>
      <td>Mixing Camera</td>
      <td>Child Camera Weight 값에 따라 활성화/비활성화 해주는 카메라</td>
    </tr>
    <tr>
      <td>2D Camera</td>
      <td>직교 뷰로 사용되는 카메라</td>
    </tr>
  </tbody>
</table>

<h2 id="프로퍼티-설명">프로퍼티 설명</h2>
<hr />
<p>💡 가장 기본적인 Virtual Camera의 설명<br />
<img src="/assets/img/Unity/Cinemachine_5.png" alt="image" /><br /><br />
Save During Play: 에디터 Play 중 내용을 변경해도 설정 저장<br /><br />
Priority: 카메라 우선도<br /><br />
Follow: 따라다닐 오브젝트<br /><br />
Look At: 바라볼 오브젝트<br /><br />
Standby Update: Live 상태가 아닌 카메라의 업데이트 빈도</p>
<ul>
  <li>Never: 항상</li>
  <li>Always: Live 일때만</li>
  <li>Round Robine: 정기적으로</li>
</ul>

<p>Transitions: 카메라 사이 이동시 씬 전환 효과<br /><br />
Body: 카메라의 위치<br /><br />
Aim: 카메라의 각도<br /></p>

<h2 id="body">Body</h2>
<hr />
<p><img src="/assets/img/Unity/Cinemachine_6.png" alt="image" /><br /><br />
Follow Offset: 카메라와 대상의 거리<br /><br />
Damping(제동): 값의 급격한 변화를 꺾어 부드럽게 이어주는 비율, 값이 커질 수록 부드러워져 민감도가 줄어듬</p>

<h2 id="aim">Aim</h2>
<hr />
<p><img src="/assets/img/Unity/Cinemachine_7.png" alt="image" /><br /><br />
Tracked Object Offset: 대상에서 얼마나 더 떨어진 곳에서 바라볼지 (y값을 늘리면 대상보다 높은 곳을 조준한다)<br /><br />
Damping: 회전 속도에 대한 제동값<br /><br />
Dead Zone: 데드존의 크기<br /><br />
Soft Zone: 소프트존의 크기<br /></p>

<h2 id="soft-zone-dead-zone">Soft Zone, Dead Zone</h2>
<hr />
<p><img src="/assets/img/Unity/Cinemachine_8.png" alt="image" /><br /><br />
<span style="color:red">
Dead Zone(데드존)
</span>: 대상이 데드존 내에서 움직이는 동안에는 카메라가 회전하지 않는다<br /><br />
<span style="color:blue">
Soft Zone(소프트존)
</span>: 대상이 소프트존 내에 있다면 카메라가 부드럽게 회전하여 대상이 데드존 안으로 들어가게 한다<br /><br />
<span style="color:yellow">
하드리밋
</span>: 소프트존보다 바깥에 있어 더 빠르고 격한 속도로 회전하며 대상이 데드존 안으로 들어가게 함<br /><br /></p>

<p><code class="language-plaintext highlighter-rouge">데드존이 클 수록 화면은 느리고 부드럽게 움직이며, 데드존이 작을수록 화면은 빠르고 격하게 움직임</code></p>

<h2 id="테스트">테스트</h2>
<hr />
<p>오브젝트를 생성하여 상하좌우로 움직이는 코드를 구현한 후 시네머신의 Follow, Look At에 연결해주었다.<br />
<img src="/assets/img/Unity/Cinemachine_9.gif" alt="image" /><br /><br /></p>

<p>카메라가 회전하여 오브젝트가 데드존으로 들어가게 하는 것을 볼 수 있다.</p>]]></content><author><name>Mindol</name></author><category term="Unity" /><category term="unity" /><category term="study" /><summary type="html"><![CDATA[Unity Cinemachine]]></summary></entry><entry><title type="html">Unity 플랫폼별 구분하여 작업</title><link href="http://localhost:4000/unity/2023/02/03/Different-for-each-Platform.html" rel="alternate" type="text/html" title="Unity 플랫폼별 구분하여 작업" /><published>2023-02-03T06:00:01+09:00</published><updated>2023-02-03T06:00:01+09:00</updated><id>http://localhost:4000/unity/2023/02/03/%20Different%20for%20each%20Platform</id><content type="html" xml:base="http://localhost:4000/unity/2023/02/03/Different-for-each-Platform.html"><![CDATA[<h2 id="플랫폼-의존-컴파일">플랫폼 의존 컴파일</h2>
<hr />
<p>유니티를 작업하다보면 플랫폼에 따라 다르게 동작해야하는 경우가 있다. 그럴때는 Unity의 <code class="language-plaintext highlighter-rouge">플랫폼 의존 컴파일</code> 기능을 이용하여 여러 플랫폼을 대응할 수 있다.<br /></p>

<h2 id="플랫폼에-따른-코드-구현">플랫폼에 따른 코드 구현</h2>
<hr />
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if 심볼(플랫폼)
</span>    <span class="c1">// 코드 작성</span>
<span class="cp">#endif
</span></code></pre></div></div>
<p>이렇게 코드를 작성해 주면 해당 플랫폼에서만 동작하는 코드를 작성할 수 있다. Unity에 지정되어있는 심볼로 아래가 있다.<br />
<img src="/assets/img/Unity/Platform_1.png" alt="image" /><br /><br />
<a href="https://docs.unity3d.com/kr/current/Manual/PlatformDependentCompilation.html">링크-유니티 공식 문서</a><br /></p>

<h2 id="예시">예시</h2>
<hr />
<p><img src="/assets/img/Unity/Platform_2.png" alt="image" width="50%" height="50%" /><br />
플랫폼에 따라 화면에 보이는 Text가 다르게 변화하도록 코드를 작성한다.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
<span class="cp">#if UNITY_EDITOR                        // Unity Editor
</span>        <span class="n">printText</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="s">"Platform: Unity Editor"</span><span class="p">;</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Editor"</span><span class="p">);</span>
<span class="cp">#endif
#if UNITY_STANDALONE_WIN                // Window
</span>        <span class="n">printText</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="s">"Platform: Window"</span><span class="p">;</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Window"</span><span class="p">);</span>
<span class="cp">#endif
#if UNITY_STANDALONE_OSX                // macOS
</span>        <span class="n">printText</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="s">"Platform: OSX"</span><span class="p">;</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"OSX"</span><span class="p">);</span>
<span class="cp">#endif
#if UNITY_IOS                           // IOS
</span>        <span class="n">printText</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="s">"Platform: IOS"</span><span class="p">;</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"IOS"</span><span class="p">);</span>
<span class="cp">#endif
#if UNITY_ANDROID                       // Android
</span>        <span class="n">printText</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="s">"Platform: Android"</span><span class="p">;</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Android"</span><span class="p">);</span>
<span class="cp">#endif
</span>    <span class="p">}</span>
</code></pre></div></div>

<h2 id="실행결과">실행결과</h2>
<hr />
<p>Window로 빌드한 결과 잘 되는것을 볼 수 있다.<br />
<img src="/assets/img/Unity/Platform_3.png" alt="image" width="50%" height="50%" /><br /><br />
하지만 Unity Editor상에서도 똑같은 결과가 나오는 것을 확인 할 수 있다.<br />
<img src="/assets/img/Unity/Platform_4.png" alt="image" width="50%" height="50%" /><br /><br />
그 이유는 Build Setting중 Platform이 Window로 되어있기 때문에, Editor에서 실행되는 코드와 Window에서 실행되는 코드 둘 다 실행되기 때문이다.<br />
콘솔창을 확인해 보면 Editor, Window 둘다 출력되는 것을 볼 수 있다.<br />
<img src="/assets/img/Unity/Platform_5.png" alt="image" width="50%" height="50%" /><br /><br />
Platform을 Android로 변경한 후 다시 실행시켜보면 Android가 출력되는 것을 볼 수 있다.<br />
<img src="/assets/img/Unity/Platform_6.png" alt="image" width="50%" height="50%" /><br /><br />
<img src="/assets/img/Unity/Platform_7.png" alt="image" width="50%" height="50%" /></p>]]></content><author><name>Mindol</name></author><category term="Unity" /><category term="unity" /><category term="study" /><summary type="html"><![CDATA[Unity 플랫폼 의존 컴파일]]></summary></entry></feed>